<?xml version="1.0" encoding="UTF-8"?><?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?><TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:lim="https://dhil.lib.sfu.ca/lyoninmourning" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:sqf="http://www.schematron-quickfix.com/validator/process" xml:lang="en">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Schema and Encoding Guidelines for the <title level="m">Lyon in Mourning</title> Project</title>
            <respStmt>
               <resp>Principle Investigator</resp>
               <name>Leith Davis</name>
            </respStmt>
         </titleStmt>
         <publicationStmt>
            <p>Probably free?</p>
         </publicationStmt>
         <sourceDesc>
            <p>No source; born digital.</p>
         </sourceDesc>
      </fileDesc>
      <encodingDesc>
         <charDecl>
            <glyph xml:id="char_star">
                <unicodeProp name="Name" value="STAR / ASTERISK"/>
                <mapping type="standard">*</mapping>
                <mapping type="unicode">U+002A</mapping>
                <figure>
                   <graphic url="img:char_star.svg"/> 
                </figure>
            </glyph>
            <glyph xml:id="char_cross">
               <unicodeProp name="Name" value="CROSS OR DAGGER"/>
               <mapping type="standard">✝</mapping>
               <mapping type="unicode">U+271D</mapping>
               <figure>
                  <graphic url="img:char_cross.svg"/>
               </figure>
            </glyph>
            <glyph xml:id="char_x">
               <unicodeProp name="Name" value="X"/>
               <mapping type="standard">X</mapping>
            </glyph>
            <glyph xml:id="char_circledX">
               <unicodeProp name="Name" value="X WITH CIRCLE"/>
               <mapping type="standard">ⓧ</mapping>
            </glyph>
            <glyph xml:id="char_phi">
               <unicodeProp name="Name" value="PHI"/>
               <mapping type="standard">φ</mapping>
               <mapping type="unicode">U+03C6</mapping>
            </glyph>
            <glyph xml:id="char_theta">
               <unicodeProp name="Name" value="THETA"/>
               <mapping type="standard">θ</mapping>
               <mapping type="unicode">U+03B8;</mapping>
            </glyph>
            <glyph xml:id="char_umbrella">
               <unicodeProp name="Name" value="UMBRELLA"/>
               <mapping type="standard">☂</mapping>
               <figure>
                  <graphic url="img:char_umbrella.svg"/>
               </figure>
            </glyph>
            <glyph xml:id="char_tau">
               <unicodeProp name="Name" value="TAU"/>
               <mapping type="standard">Τ</mapping>
            </glyph>
            <glyph xml:id="char_pi">
               <unicodeProp name="Name" value="PI"/>
               <mapping type="standard">Π</mapping>
            </glyph>
            <glyph xml:id="char_UNKNOWN">
               <unicodeProp name="Name" value="UNKNOWN"/>
               <desc>An unknown character to be used as a placeholder until
               a character can be properly assigned.</desc>
            </glyph>
         </charDecl>
         <classDecl>
            <taxonomy>
               <desc>Genre</desc>
               <category xml:id="letter">
                  <catDesc>
                     <term>letter</term>
                     <gloss/>
                  </catDesc>
               </category>
               <category xml:id="speech">
                  <catDesc>
                     <term>speech</term>
                     <gloss/>
                  </catDesc>
               </category>
               <category xml:id="conversation">
                  <catDesc>
                     <term>conversation</term>
                  </catDesc>
               </category>
               <category xml:id="accountNarrative">
                  <catDesc>
                     <term>account/narrative</term>
                  </catDesc>
               </category>
               <category xml:id="text">
                  <catDesc>
                     <term>text</term>
                  </catDesc>
                  <category xml:id="text_poem">
                     <catDesc>
                        <term>poem</term>
                     </catDesc>
                  </category>
                  <category xml:id="text_song">
                     <catDesc>
                        <term>poem</term>
                     </catDesc>
                  </category>
                  <category xml:id="text_epitaph">
                     <catDesc>
                        <term>epitaph</term>
                     </catDesc>
                  </category>
               </category>
               <category xml:id="insert">
                  <catDesc>
                     <term>insert</term>
                  </catDesc>
               </category>
               <category xml:id="misc">
                  <catDesc>
                     <term>Miscellaneous</term>
                  </catDesc>
               </category>
            </taxonomy>
            <taxonomy xml:id="docStatus">
               <bibl>Document Status taxonomy</bibl>
               <category xml:id="docStatus_empty">
                  <catDesc>
                     <term>empty</term>
                     <gloss>empty / not yet worked on or edited</gloss>
                  </catDesc>
                  <category xml:id="docStatus_inProgress">
                     <catDesc>
                        <term>in progress</term>
                        <gloss>currently being worked on, but not yet "done"</gloss>
                     </catDesc>
                  </category>
                  <category xml:id="docStatus_readyForProof">
                     <catDesc>
                        <term>ready for proof</term>
                        <gloss>corrected and encoded, and is now ready to be proofed</gloss>
                     </catDesc>
                  </category>
                  <category xml:id="docStatus_proofed">
                     <catDesc>
                        <term>proofed</term>
                        <gloss>proofed and checked</gloss>
                     </catDesc>
                  </category>
               </category>
            </taxonomy>
         </classDecl>

         <tagsDecl>
            <!--HOW THIS WORKS:
               @xml:id = the rendition pointer,
               desc / gloss = the desc and gloss in the ODD
               outputRendition = the CSS styling-->
            <rendition xml:id="rnd_super">
               <desc>Superscript</desc>
               <gloss>Superscripted letters</gloss>
               <outputRendition>text-align:super;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_sub">
               <desc>Subscript</desc>
               <gloss>Subscripted letters</gloss>
               <outputRendition>text-align:sub;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_underlined">
               <desc>Underlined</desc>
               <gloss>Items that are underlined; note that since underlining often denotes
               emphasis, this should usually be used with more precise elements (persName, emph, etc)</gloss>
               <outputRendition>text-decoration:underline;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_right-braced">
               <desc>Right braced</desc>
               <gloss>A set of elements with a CURLY right brace</gloss>
            </rendition>
            <rendition xml:id="rnd_bordered-all">
               <desc>Bordered on all four sides</desc>
               <gloss>Items that have a full border</gloss>
               <outputRendition>border:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-left">
               <desc>Left bordered</desc>
               <gloss>Items that have a left border (straight or ragged)</gloss>
               <outputRendition>border-left:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-right">
               <desc>Right bordered</desc>
               <gloss>An element with a right border (straight or ragged)</gloss>
               <outputRendition>border-right:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-bottom">
               <desc>Bottom bordered</desc>
               <gloss>An element with a bottom border (straight or ragged)</gloss>
               <outputRendition>border-bottom:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-bottom-dashed">
               <desc>Bottom bordered</desc>
               <gloss>An element with a dashed bottom border</gloss>
               <outputRendition>border-bottom:1px dashed black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-top">
               <desc>Top bordered</desc>
               <gloss>An element with a bottom border (straight or ragged)</gloss>
               <outputRendition>border-top:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bold">
               <desc>Bold</desc>
               <gloss>Bold or heavier weight. TODO: What is the difference between
               bold and a shift in ink?</gloss>
               <outputRendition>font-weight:bold;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_indent-first-line">
               <desc>Indent</desc>
               <gloss>A paragraph or poetic line that has a first line indent.</gloss>
               <outputRendition>text-indent: 1rem;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_indent-block">
               <desc>Indented block</desc>
               <gloss>A block element that is entirely indented (i.e. a paragraph). Use the @n attribute as a multiplier.</gloss>
               <outputRendition>margin-left: 1rem;</outputRendition>
            </rendition>
            
            <rendition xml:id="rnd_overline">
               <desc>Overline</desc>
               <gloss>An element with a line above. Note: this should NOT be used for letters with macrons (i.e. ō);
                  if those ever appear, use the actual letter.</gloss>
               <outputRendition>text-decoration: overline;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_small">
               <desc>Small text</desc>
               <gloss>Use for marginal notes etc, if they are smaller</gloss>
               <outputRendition>font-size: 0.8em;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_large" select="head">
               <desc>Larger text (i.e. headings)</desc>
               <gloss>Use this for headings or other large text</gloss>
               <outputRendition>font-size: 1.5rem;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_strikethrough" selector="del">
               <desc>Strikethrough</desc>
               <gloss>Use this for text that is struck through; note that,
               by default, you do not need to put this element for dels.</gloss>
               <outputRendition>text-decoration:line-through;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_normal">
               <desc>Normal</desc>
               <gloss>This text should NOT follow any of the default assumptions
               about its styling (i.e. a heading that is NOT large; a deletion that is
               not struck through)</gloss>
            </rendition>
            <rendition xml:id="rnd_left">
               <desc>Left aligned</desc>
               <gloss>Left aligned text</gloss>
               <outputRendition>text-align: left;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_right">
               <desc>Right aligned</desc>
               <gloss>Left aligned text</gloss>
               <outputRendition>text-align: right;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_center">
               <desc>Centered</desc>
               <gloss>Centered text</gloss>
               <outputRendition>text-align: center;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_embellished">
               <desc>Embellished letter</desc>
               <gloss>Use this when some letter/character is embellished.</gloss>
            </rendition>
            <rendition xml:id="rnd_two-column">
               <desc>A block that has two columns</desc>
               <gloss>Used for instances where (usually a closer) has two distinct
               blocks with something in the left and right-column</gloss>
            </rendition>
            <rendition xml:id="rnd_rotate-left">
               <desc>A block rotated -90 degrees.</desc>
               <gloss>Used for notes, annotations, et cetera that are rotated -90 degrees (i.e.
               read from bottom to top)</gloss>
               <outputRendition>transform: rotate(-90deg);</outputRendition>
            </rendition>
            <rendition xml:id="rnd_rotate-right">
               <desc>A block rotated 90 degrees.</desc>
               <gloss>Used for notes, annotations, et cetera that are rotated 90 degrees (i.e.
               read from top to bottom)</gloss>
               <outputRendition>transform: rotate(90deg);</outputRendition>
            </rendition>
         </tagsDecl>
         <listPrefixDef>
            <prefixDef ident="doc" matchPattern="(.+)(#.+)?" replacementPattern="$1.xml$2">
               <p>Mechanism for pointing to a document in the repository. E.g. <val>doc:vol11_vol1</val>.</p>
            </prefixDef>
            <prefixDef ident="islandora" matchPattern="(\d+)" replacementPattern="https://digital.lib.sfu.ca/islandora/object/lyoninmourning:$1">
               <p>Resolves links to SFU's Islandora collection for the Lyon in Mourning page images.</p>
            </prefixDef>
            <prefixDef ident="lib" matchPattern="(\d+)" replacementPattern="#sfu_pg_$1">
               <p>Resolves links from a page in a volume to a facsimile element.</p>
            </prefixDef>
            <prefixDef ident="lim" matchPattern="(.+)" replacementPattern="lim.odd#$1"/>
            <prefixDef ident="prs" matchPattern="(.+)" replacementPattern="people.xml#$1">
               <p>Resolves links to a person to the personography.</p>
            </prefixDef>
            <prefixDef ident="plc" matchPattern="(.+)" replacementPattern="places.xml#$1">
               <p>Resolves links to a place to the geography.</p>
            </prefixDef>
            <prefixDef ident="team" matchPattern="(.+)" replacementPattern="contributors.xml#$1">
               <p>Resolve links to team members.</p>
            </prefixDef>
            <prefixDef ident="org" matchPattern="(.+)" replacementPattern="organizations.xml#$1">
               <p>Resolves links to a place to the geography.</p>
            </prefixDef>
            <prefixDef ident="obj" matchPattern="(.+)" replacementPattern="objects.xml#$1">
               <p>Resolves links to an object to the object database.</p>
            </prefixDef>
            <prefixDef ident="bibl" matchPattern="(.+)" replacementPattern="bibliography.xml$1">
               <p>Resolves links to a bibliographic item.</p>
            </prefixDef>
            <prefixDef ident="img" matchPattern="(.+)" replacementPattern="images/$1"/>
            <prefixDef ident="g" matchPattern="(.+)" replacementPattern="lim.odd#char_$1">
               <p>Resolves links to a glyph.</p>
            </prefixDef>
         
         </listPrefixDef>
      </encodingDesc>
   </teiHeader>
   <text>
      <front>
         <div>
            <head>Lyon in Mourning Encoding Guidelines</head>
            <p>This is the encoding documentation for the forthcoming <ref target="https://dhil.lib.sfu.ca/lyoninmourning">Lyon in Mourning digital edition</ref>, which is part of the larger SSHRC-funded Networking Jacobites project (Leith Davis [SFU, Department of English], Ralph MacLean [National Library of Scotland], and Joey Takeda [SFU, Digital Humanities Innovation Lab]).</p>
         </div>
      </front>
      <body>
         
            
<div xml:space="preserve" xml:id="helpful_links">
  <head>Helpful Links</head>
  <list type="unordered">
    <item>
      <p><ref target="https://digital.lib.sfu.ca/lyoninmourning-collection/lyon-mourning">Lyon
      in Mourning facsimiles (SFU)</ref></p>
    </item>
    <item>
      <p><ref target="https://docs.github.com/en/desktop">GitHub Desktop
      Documentation</ref></p>
    </item>
    <item>
      <p><ref target="https://tei-c.org/guidelines/">TEI
      Guidelines</ref></p>
    </item>
    <item>
      <p>Paton Edition:</p>
      <list type="unordered">
        <item>
          <p>Volume 1</p>
          <list type="unordered">
            <item>
              <p><ref target="https://www.gutenberg.org/files/43222/43222-h/43222-h.htm">Full
              Text Transcription (Project Gutenberg)</ref></p>
            </item>
            <item>
              <p><ref target="https://digital.nls.uk/print/transcriptions/lyon/vol1/index.html">Indexed
              PDF (NLS)</ref></p>
            </item>
            <item>
              <p><ref target="https://view.nls.uk/mirador/125649979">Zoomable
              Book Viewer (NLS)</ref></p>
            </item>
          </list>
        </item>
        <item>
          <p>Volume 2:</p>
          <list type="unordered">
            <item>
              <p><ref target="https://digital.nls.uk/print/transcriptions/lyon/vol2/index.html">Indexed
              PDF (NLS)</ref></p>
            </item>
          </list>
        </item>
        <item>
          <p>Volume 3:</p>
          <list type="unordered">
            <item>
              <p><ref target="https://digital.nls.uk/print/transcriptions/lyon/vol3/index.html">Indexed
              PDF (NLS)</ref></p>
            </item>
          </list>
        </item>
      </list>
    </item>
  </list>
</div>

<div xml:space="preserve" xml:id="getting_started">
  <head>Getting Started</head>
  <div xml:id="getting_started_setting-up">
    <head>Setting up</head>
    <p>Before working on the LiM documents, there are two pieces of
    software you will need to install: oXygen XML Editor and Github
    Desktop. You will also need a Github account.</p>
    <list type="unordered">
      <item>
        <p>Provide the DHIL with your GitHub account username. If you do
        not have a GitHub account, you can create a free account here:
        <ref target="https://github.com/join">https://github.com/join</ref>.</p>
      </item>
      <item>
        <p>Download and install
        oXygen:<ref target="https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html">https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html</ref>.
        Members of the LiM team should contact the DHIL regarding
        license keys.</p>
      </item>
      <item>
        <p>Download and install the GitHub desktop client:
        <ref target="https://desktop.github.com/">https://desktop.github.com/</ref></p>
      </item>
    </list>
    <div xml:id="getting_started_setting-up-the-repository">
      <head>Setting up the Repository</head>
      <p>The main data repository for the project is
      <code>lim-data</code>. At the moment, this is a private
      repository, which means you must first be invited as a
      contributor. Once you've made your GitHub account, let an
      administrator from the DHIL know your GitHub username and they
      will invite you to join the repository; note that this invitation
      may take up to an hour to wend its way through the email system
      (especially if you are using your SFU email). Once you receive
      that email, make sure to accept the invitation for the lim-data
      repository.</p>
      <p>For the LiM project, we use a "fork" workflow. This
      means that, rather than contributing directly to the main
      repository, each team member maintains a local copy of the files
      that are then pushed up to the main repository. To create your own
      fork, do the following:</p>
      <p>Create a fork repository on GitHub website. Log in to your ID
      and click on “Fork”. <figure>
        <figDesc>image1</figDesc>
        <graphic url="images/1.1.png"/>
      </figure></p>
      <p>Open GitHub Desktop. <figure>
        <figDesc>image2</figDesc>
        <graphic url="images/1.2.png"/>
      </figure></p>
      <p>Click on “Clone a Repository from the Internet”. <figure>
        <figDesc>image3</figDesc>
        <graphic url="images/1.3.png"/>
      </figure></p>
      <p>Ensure that the page is refreshed. Then, click on your
      repository (eg. shaunajudith/lim-data), select a local path of
      your choice (eg. Desktop), and then click on “Clone”. <figure>
        <figDesc>image4</figDesc>
        <graphic url="images/1.4.png"/>
      </figure></p>
      <p>A pop up may appear asking “How are you planning to use this
      fork?”. Select “To contribute to the parent project” and click
      “Continue”. <figure>
        <figDesc>image5</figDesc>
        <graphic url="images/1.5.png"/>
      </figure></p>
      <p>Open Oxygen XML Editor. Click on “sample.xpr” and then “Open
      Project". <figure>
        <figDesc>image6</figDesc>
        <graphic url="images/1.6.png"/>
      </figure></p>
      <p>Open the lim-data folder created earlier, select “lim.data.xpr”
      and click “Open”. A pop-up will ask you to confirm your selection,
      click “Yes”. <figure>
        <figDesc>image7</figDesc>
        <graphic url="images/1.7.png"/>
      </figure></p>
      <p>Go to the top panel, click on “Oxygen XML Editor” and select
      “Preferences”. <figure>
        <figDesc>image8</figDesc>
        <graphic url="images/1.8.png"/>
      </figure></p>
      <p>In the “Type filter text” box, type in the word “wrap”. Then,
      under “text”, check the box next to “Line wrap”. <figure>
        <figDesc>image9</figDesc>
        <graphic url="images/1.9.png"/>
      </figure>'</p>
    </div>
  </div>
</div>

<div xml:space="preserve" xml:id="workflow">
  <head>Workflow</head>
  <p>All of the documents for the LiM project are kept in GitHub, which
  is a version control software system (much like Google Drive). There
  are a number of advantages of using this approach, but, at its core,
  what this means is that every version of a file is archived; at any
  point, we can "roll back" the repository if we need to for
  whatever reason.</p>
  <p>In this project, we following a workflow called
  "forking":</p>
  <list type="unordered">
    <item>
      <p>Each contributor creates their own repository in their GitHub
      account by "forking" the main (or "upstream")
      repository</p>
    </item>
    <item>
      <p>Each contributor then downloads their version of the repository
      (or the "origin" repository) and then makes changes on
      their computer ("local")</p>
    </item>
    <item>
      <p>While a contributor is working on a task, they save their local
      changes and push them back to their version of the repository (the
      "origin")</p>
    </item>
    <item>
      <p>Once they are ready for everyone else to see their changes,
      they do a "pull request" so that the upstream repository
      reflects their changes</p>
    </item>
  </list>
  <p><figure>
    <figDesc>Diagram of forking workflow from
    <ref target="https://www.tomasbeuzen.com/post/git-fork-branch-pull/">https://www.tomasbeuzen.com/post/git-fork-branch-pull/</ref></figDesc>
    <graphic url="images/fork_workflow.png"/>
  </figure></p>
  <p>You can consider the upstream repository like an article that is
  going through publication; each editor takes a photocopy of the
  article and makes changes. When each editor has finished making their
  changes, they send it back to the publisher (here, sfu-dhil). When the
  article needs to go through the next round of revisions, the publisher
  sends out a new version of the article with your and everyone else's
  changes combined, and the editing process starts again.</p>
  <p>There are three main steps to this workflow:</p>
  <list type="ordered:arabic">
    <item>
      <p>"Pulling" from the upstream repository to update your
      fork (i.e. getting the most up-to-date version of the data)</p>
    </item>
    <item>
      <p>Commit and saving your work ("pushing" to the
      "origin" repository)</p>
    </item>
    <item>
      <p>Contributing your work back to the upstream repository (by
      issuing a "pull request")</p>
    </item>
  </list>
  <div xml:id="workflow_updating-your-repository">
    <head>Updating your Repository</head>
    <p>Update your local copy of the repository by merging any changes
    from the upstream repository. To do so:</p>
    <list type="unordered">
      <item>
        <p>Open GitHub Desktop and click the branch tab (the second tab
        on the top; it will say something like "main"):
        <figure>
          <figDesc>Branch Menu</figDesc>
          <graphic url="images/branch_menu.png"/>
        </figure></p>
      </item>
      <item>
        <p>In the branch menu, click Choose branch to merge into
        <hi rendition="simple:bold">main</hi>: <figure>
          <figDesc>Choose branch merge</figDesc>
          <graphic url="images/choose_branch_merge.png"/>
        </figure></p>
      </item>
      <item>
        <p>Click on "upstream/main": <figure>
          <figDesc>Select upstream main</figDesc>
          <graphic url="images/select_upstream_main.png"/>
        </figure></p>
      </item>
      <item>
        <p>Depending on whether your repository is up to date:</p>
        <list type="unordered">
          <item>
            <p>If there are no changes to merge (This branch is up to
            date ...), then you're done!</p>
          </item>
          <item>
            <p>If there are changes to merge (This will merge x
            commits...), then click Merge upstream/main</p>
          </item>
        </list>
      </item>
    </list>
  </div>
  <div xml:id="workflow_editing-in-oxygen">
    <head>Editing in oXygen</head>
    <p>All work on the TEI documents should be done in oXygen. It is an
    incredibly powerful and useful tool for editing XML and there are a
    number of custom features and tools that will editing easier and
    more efficient.</p>
    <p>When you open oXygen, make sure you see the
    <code>lim-data.xpr</code> project in the oXygen project
    pane (usually on the left-hand side): <figure>
      <figDesc>Project pane</figDesc>
      <graphic url="images/oxygen_splash.png"/>
    </figure></p>
    <p>oXygen remembers the last project you opened, so it will usually
    use the <code>lim-data</code> project file automatically.
    If, for whatever reason, you are not in the
    <code>lim-data</code> project, make sure to open the
    project file by going to <code>Project/Open Project</code>
    in the toolbar. You can use the Project pane to navigate through the
    project files; all of the TEI files are in the
    <code>data/</code> folder.</p>
    <p>As you edit your TEI file in oXygen, it is imperative that you
    frequently and consistently validate your file. Invalidities in an
    oXygen are signalled much like spell-check: the invalid element is
    underlined in red and its location in the document is marked in the
    scrollbar.</p>
    <p>oXygen validates for you automatically as you type, but it might
    lag (especially for large or complex documents), so it is best
    practice to trigger validation manually as well, especially before
    committing your changes.</p>
    <p>To validate your document, you can either use the keyboard
    shortcut CMD+Shift+V (CMD = ⌘ on Mac) or click the red checkmark in
    the toolbar:</p>
    <p><figure>
      <figDesc>Validate</figDesc>
      <graphic url="images/oxygen_validation_valid.png"/>
    </figure></p>
    <p>Once the document finishes validating, there will be a message at
    the bottom of the screen stating whether validation was successful.
    If there are errors in your document and validation fails, you will
    see the red underlines and a info box at the bottom of the screen
    that outlines the precise errors.</p>
    <p><figure>
      <figDesc>Validation errors</figDesc>
      <graphic url="images/oxygen_validation_errors.png"/>
    </figure></p>
    <p>Try your best to determine what the error is: the validation
    message usually provides a good indication of what the pfrom the
    validation message (some are more helpful than others); the problem
    is quite often something simple like a typo, an errant space at the
    beginning or end of an element, or a missing quotation mark.</p>
    <p>If you can't figure out the error, then it is OK to commit the
    file, but do let the team and the developers know right away so that
    the error can be resolved as soon as possible.</p>
  </div>
  <div xml:id="workflow_committing-changes">
    <head>Committing Changes</head>
    <p>After you've made a set of changes (i.e. before you take a break
    or before the end of your work day) and confirmed that they were
    valid, you need to commit those changes to the repository. To do
    that, navigate to GitHub Desktop, which should show you a list of
    changes that you've made: <figure>
      <figDesc>Changes</figDesc>
      <graphic url="images/changes.png"/>
    </figure></p>
    <p>It is a good idea to review those changes to make sure everything
    looks right (i.e. all of the files that you actually changed are
    listed; there are no additional changes). (You may see that the
    <code>lim-data.xpr</code> oXygen project file has changed
    even though you didn't do anything to it—that's expected).</p>
    <p>Assuming that everything looks correct, you can then commit those
    files by filling out the commit message boxes in the bottom
    left-hand corner:</p>
    <p><figure>
      <figDesc>Commit box</figDesc>
      <graphic url="images/commit_box.png"/>
    </figure></p>
    <p>These commit messages are helpful for record keeping and for
    tracking changes to the files; note that these commit messages are
    both permanent and public. In the <code>Summary</code>
    field, add a brief description of what you've done (i.e. "Added
    index items for vol7"). If there is additional information
    you'd like to add, put a longer explanation in the
    <code>Description</code> box.</p>
  </div>
  <div xml:id="workflow_issuing-a-pull-request">
    <head>Issuing a Pull Request</head>
    <p>When you are ready for the changes to be reflected on the
    website, you need to contribute to the main repository. Click on
    “contribute” and then “Open pull request”. <figure>
      <figDesc>image18</figDesc>
      <graphic url="images/1.18.png"/>
    </figure></p>
    <p>Review your changes and click on “Create pull request”. <figure>
      <figDesc>image19</figDesc>
      <graphic url="images/1.19.png"/>
    </figure></p>
    <p>A new window will open. Add a title and a comment to provide an
    update about the work. Click on “create a pull request” button to
    confirm. The administrator will review and accept this request.
    <figure>
      <figDesc>image20</figDesc>
      <graphic url="images/1.20.png"/>
    </figure></p>
  </div>
</div>
<div><head>Encoding Transcriptions</head>
<div xml:space="preserve" xml:id="transcription_workflow">
  <head>Transcription Encoding Workflow</head>
  <p>We use a multi-stage workflow for the transcriptions in order to
  allow for ease of collaboration during the transcription stage. All of
  the transcriptions are in the Google Drive folder; depending on the
  individual transcriber's preference, this transcription may have been
  automatically generated from Transkribus or has been transcribed by
  hand.</p>
  <p>Once the transcription has been finished and proofed according to
  the guidelines in the Google Drive, the next step is to encode the
  transcription in TEI. We have an automated process for creating a
  semi-valid TEI document from the Google Doc transcription. Since
  Google Doc is a presentation format, the transformation from the
  Google Doc to TEI will be necessarily imperfect and will require
  significant manual editing in order to ensure that the structure,
  semantics, and presentation of the text are encoded properly.</p>
  <div xml:id="transcription_workflow_step-0-update-your-repository">
    <head>Step 0: Update your repository</head>
    <p>Before encoding your transcription, make sure you have your
    GitHub and oXygen environments properly set up (see
    <ref target="getting_started.md">Getting Started</ref>) and that you
    have update your local version of the repository (see
    <ref target="workflow.md">Workflow</ref>).</p>
  </div>
  <div xml:id="transcription_workflow_step-1-check-google-drive-transcription">
    <head>Step 1: Check Google Drive Transcription</head>
    <p>The automated conversion process makes a number of assumptions
    about the format of the Transcription Roster and the Google Doc; any
    divergence from these assumptions will quite likely cause the
    transformation to fail, so it is best to ensure the following before
    proceeding to run the conversion:</p>
    <list type="ordered:arabic">
      <item>
        <p>The transcription roster MUST contain the IDs of the assigned
        transcriber, the actual transcriber, and the proofer where the
        ID is usually the person's initials and a 1 (i.e. JT1). If there
        are multiple people for a given role, separate with a slash
        (i.e. JT1/LD1).</p>
        <list type="unordered">
          <item>
            <p>Ensure that these cells DO NOT contain any spaces</p>
          </item>
        </list>
      </item>
      <item>
        <p>The document ID in the first cell MUST match the name of the
        document in Google Drive, which MUST match the name of the
        document's ID (i.e. v01.0001.01).</p>
      </item>
      <item>
        <p>Transcriptions MUST NOT contain any Track Changes (insert,
        remove, format, etc). Ensure that all track changes are resolved
        before converting (NB: comments and notes are OK as these are
        converted to XML comments
        (<gi>!-- comment --</gi>)</p>
      </item>
    </list>
    <p>Once you have confirmed the above, add your ID to the ENCODER
    column. This is important as we want to avoid multiple people
    encoding an item.</p>
  </div>
  <div xml:id="transcription_workflow_step-2-convert-the-transcription">
    <head>Step 2: Convert the Transcription</head>
    <list type="ordered:arabic">
      <item>
        <p>Open the Google Doc transcription and copy the document's
        URL</p>
      </item>
      <item>
        <p>Open oXygen (and confirm you are in the lim-data project--it
        should say <code>lim-data.xpr</code> in the corner</p>
      </item>
      <item>
        <p>Scroll to the bottom of the project pane, find the file named
        <code>convertTranscription.html</code>, and
        double-click it to open it</p>
      </item>
    </list>
    <p><figure>
      <figDesc>Conversion page</figDesc>
      <graphic url="images/convert_convertPage.png"/>
    </figure></p>
    <list type="ordered:arabic">
      <item>
        <p>Then press the red "Play" button (a white circle
        with a red triangle)</p>
      </item>
    </list>
    <p><figure>
      <figDesc>Conversion page</figDesc>
      <graphic url="images/convert_convertPageButton.png"/>
    </figure></p>
    <list type="ordered:arabic">
      <item>
        <p>The first is your encoder ID. Enter your id (i.e. LD1) and
        press OK</p>
      </item>
    </list>
    <p><figure>
      <figDesc>encoder ID popup</figDesc>
      <graphic url="images/convert_idPopup.png"/>
    </figure></p>
    <list type="ordered:arabic">
      <item>
        <p>The second is the Google Doc URL. Paste in the Google Doc's
        URL and press OK</p>
      </item>
    </list>
    <p><figure>
      <figDesc>encoder ID popup</figDesc>
      <graphic url="images/convert_googleDocPopup.png"/>
    </figure></p>
    <p>A pane should appear at the bottom of your oXygen application
    with a bunch of messages that scroll past as the conversion process
    proceeds. This will take about a minute or so.</p>
    <p>Once the conversion is finished (and if it did not encounter any
    errors), then the document should automatically open in a new tab in
    oXygen and the information at the bottom should say "BUILD
    SUCCESSFUL"</p>
    <p><figure>
      <figDesc>encoder ID popup</figDesc>
      <graphic url="images/convert_success.png"/>
    </figure></p>
    <p>If all was successful, you can close the results pane:</p>
    <p><figure>
      <figDesc>encoder ID popup</figDesc>
      <graphic url="images/convert_successClose.png"/>
    </figure></p>
    <p>If the conversion fails, then a secondary tab will appear at the
    bottom and will say something dramatic and unhelpful like
    "FATAL ERROR."</p>
    <p><figure>
      <figDesc>encoder ID popup</figDesc>
      <graphic url="images/convert_fail.png"/>
    </figure></p>
    <p>If you see this, then there are a few steps you can take to try
    and debug. Often, these errors are caused by some inconsistency in
    the Transcription Roster, so double check that everything is
    formatted as described above.</p>
    <p>If the Roster looks OK, then check the "ANT
    [convertGoogleDoc]" tab. There will be a lot of superfluous
    information in that window, but try scrolling up a few lines and
    seeing if you can find a line that begins with the words
    "ERROR." These are customized error messages for this
    project, which attempt to explain what caused the error. For
    instance, in this example, the document had already been
    transcribed:</p>
    <p><figure>
      <figDesc>encoder ID popup</figDesc>
      <graphic url="images/convert_failInfo.png"/>
    </figure></p>
    <p>If you can't find a line like that or if it's not clear how to
    resolve the issue, then the best course of action is to get in touch
    with the LiM team using the RAs email list, which includes the DHIL
    developer. It may be the case that another person has encountered
    the same issue and knows how to fix it or there is something broken
    with the conversion script. Please include the output of the ANT
    [convertGoogleDoc] tab at the bottom of your message (it will be a
    lot of text) since this will help with debugging the issue.</p>
  </div>
  <div xml:id="transcription_workflow_step-3-encoding-the-transcription">
    <head>Step 3: Encoding the Transcription</head>
    <p>The automatically generated transcription will almost certainly
    be riddled with validation errors. These are expected and wanted:
    the conversion tries to make some educated guesses about formatting,
    etc, but will usually produce generic or intentionally invalid TEI
    in order to flag places where human intervention is required.</p>
    <p>The overall goal of this first pass of encoding is to make sure
    the document is valid and accurately represents the source material.
    While each document will have different requirements in terms of
    encoding, there are some common errors that appear within
    documents.</p>
    <p>TODO: Add table of errors with solutions</p>
  </div>
</div>

<div xml:space="preserve" xml:id="encoding_common">
  <head>Common Bibliographical / Structural Features</head>
  <div xml:id="encoding_common_line-beginnings">
    <head>Line Beginnings</head>
    <p>Each line of prose within a heading or paragraph must be marked
    explicitly with the self-closing line-beginning (
    <gi>lb</gi>) element. Only mark line
    beginnings within prose (i.e. a paragraph, heading, note, et
    cetera); new lines between structural elements like paragraphs and
    headings do not need to be encoded and lines within poems should be
    encoded according to the documentation on Poetry.</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
 After making Offer of
 <lb/>my Compliments to yourself &amp;
 <lb/>the Leith-Ladies, no Doubt, you 
 <lb/>have heard before now that our
 <lb/>Trials come on the Ninth of Sept.
</egXML>
  </div>
  <div xml:id="encoding_common_page-beginnings">
    <head>Page Beginnings</head>
    <p>Since we are primarily concerned with the intellectual content of
    the manuscript, our encoding does not attempt to replicate the
    exactly layout of the page. Instead, pages are represented by the
    self-closing <gi>pb</gi> element, which does
    not contain any content itself, but marks the beginning of a new
    page.</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
Some content on the first page
<pb/>
Some content on the second page
</egXML>
    <p>The <gi>pb</gi> element requires the
    <att>facs</att> attribute to point to the page that it
    represents. To point to the page, use the special
    <code>pg</code> prefix, followed by a colon, and the
    "collection" page number (see
    <ref target="facsimilies.md">Encoding Facsimiles</ref> for
    documentation on the different kind of page numbers):</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<pb facs="pg:190"/>
<!--
Content for page 190 here ...
-->

<pb facs="pg:191"/>
<!--
Content for page 191 here ... 
-->
</egXML>
  </div>
  <div xml:id="encoding_common_formeworks">
    <head>Formeworks</head>
    <p>Bibliographic features that precede and following page beginnings
    (catchwords and page numbers) should be encoded using the
    <gi>fw</gi> element. Use the
    <att>type</att> attribute on to classify the formework
    (<code>pageNum</code> for a page number,
    <code>catchword</code> for a catchword) and the
    <att>place</att> attribute to describe where it is on
    the page:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<pb facs="pg:190"/>
<fw type="pageNum" place="center">(190)</fw>
</egXML>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<fw type="catchword" place="right">Reel</fw>
<pb facs="pg:71"/>
<fw type="pageNum" place="center">(71)</fw>
</egXML>
    <p>Formeworks and page beginnings can appear anywhere in the
    document, including within paragraphs, et cetera. When a paragraph
    is split between pages, do not create a new paragraph, but simply
    encode the formework and page beginning where it happens:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
               <p><!-- Lines at the beginning of the paragraph...-->
               <lb/>to Miss Mally Clerk, &amp; tell her 
               <lb/>that, notwithstanding of my <w>I<pc force="weak">-</pc>
               <lb/>rons</w> I could dance a highland
               <fw type="catchword" place="right">Reel</fw>
               <pb facs="pg:71"/>
               <fw type="pageNum" place="center">(71)</fw>
               <lb/>Reel with her. Mr Patrick <w>Mur<pc force="weak">-</pc>
               <lb/>ray</w> makes offer of his <w>Compli<pc force="weak">-</pc>
               <lb/>ments</w> to you, &amp; I hope, we'll
               <lb/>meet soon,</p>
</egXML>
    <p>If the item you're encoding does not start at the beginning of
    the page (i.e. it begins in the middle of the page), you do not need
    to have an initial <gi>pb</gi> element.</p>
  </div>
  <div xml:id="encoding_common_end-of-line-hyphens">
    <head>End of Line Hyphens</head>
    <p>End of line hyphens require special encoding to signal that a)
    the hyphen is incidental and b) that the word the hyphens splits
    should be reconsituted when indexed by search engines, etc.</p>
    <p>In all cases, the first step is to tag the hyphen using the
    <gi>pc</gi> element with an
    <att>force</att> value of <att>weak</att>,
    which means that this is a punctuation character that does not break
    the word.</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<lb/>the whole will be soon provid<pc force="weak">-</pc>
<lb/>ed. You'll make my Compli<pc force="weak">-</pc>
<lb/>ments to Lady Bruce, &amp; Mr
</egXML>
    <p>When a word is split across a line, surround the entire word,
    including the <gi>pc</gi> and the
    <gi>lb</gi>, with the
    <gi>w</gi> tag:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<lb/>the whole will be soon <w>provid<pc force="weak">-</pc>
<lb/>ed</w>. You'll make my <w>Compli<pc force="weak">-</pc>
<lb/>ments</w> to Lady Bruce, &amp; Mr
</egXML>
    <p>Words split across a page beginning require more complex
    encoding, since we must avoid claiming that formeworks are part of
    the hyphenated word. When a word is split across a page boundary,
    each part of the word should be enclosed in a
    <gi>w</gi> element that also contains a
    <att>part</att> attribute; this
    <att>part</att> attribute should have a value of
    "I" for the initial part of the word and "F" for
    the final part of the word. For example:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<lb/>Trumpet &amp; Beat of Kettle-Drums, a <w part="I">Cir<pc force="weak">-</pc></w>
<fw type="catchword" place="right">cumstance</fw>
<pb facs="pg:222"/>
<fw type="pageNum" place="center">(222)</fw>
<lb/><w part="F">cumstance</w> very much noticed by every
</egXML>
  </div>
  <div xml:id="encoding_common_horizontal-rules">
    <head>Horizontal Rules</head>
    <p>Horizontal rules are lines written in the document that delimit
    structures and signal some sort of structural shift. These are
    distinct from underlines and borders and should only be used in
    cases where the primary function of the line is organizational and
    not semantic.</p>
    <p>To encode these, we use the custom
    <gi>rule</gi> element:</p>
    <specDesc key="rule" atts="unit extent place"/>
    <p>The <att>unit</att> attribute is mandatory and must
    be one of either "section" (for all horizontal rules that
    mark changes in sections) or "item".</p>
    <p>Use <code>unit="section"</code> when the line
    separates parts of an item; e.g. the line between a postscript and a
    signature, et cetera. These should always be between the two
    structural elements that the line delimits; e.g.:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<closer>
<!--[...]-->
</closer>
<rule unit="section"/>
<postscript>
    <p><!--[...]--></p>
</postscript>
</egXML>
    <p>Encode the line that separates two items (i.e. the final
    horizontal line at the end of one item) using the
    <code>unit="item"</code> at after the end
    <gi>body</gi> tag; these lines should only be
    encoded for the item that it ends.</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<text>
    <body>
        <!--[ All of the body content for the transcription ]-->
        <signed>R.F</signed>
    </body>
    <rule unit="item"/>
</text>
</egXML>
    <div xml:id="encoding_common_styling-horizontal-rules">
      <head>Styling Horizontal Rules</head>
      <p>Given the variation of rules in the manuscript, we do not try
      to replicate the precise curvature, style, or shape of a given
      horizontal rule. However, we do capture the length and position of
      the rule where possible.</p>
      <p>If the line separating is significantly shorter than the width
      of the page, then use the <att>extent</att> attribute
      to specify a percentange of the page the rule occupies (i.e. 25%,
      50%, etc). You do not need to specify
      <att>extent</att> if the rule spans the width of the
      page. Shorter rules can also be placed left or right using the
      <att>place</att> attribute (note that
      <att>place</att> is only valid if the rule has an
      <att>extent</att> less than 100%).</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<rule unit="section" extent="50%" place="right"/>
</egXML>
      <p>If there are any other stylistic features you think are worth
      noting, use the <gi>desc</gi> element within
      the <gi>rule</gi>:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<rule unit="section">
<desc>Line curves around catchword</desc>
</rule>
</egXML>
    </div>
  </div>
  <div xml:id="encoding_common_source-styling">
    <head>Source Styling</head>
    <divGen xml:id="rendition_list"/>
  </div>
</div>

<div xml:space="preserve" xml:id="encoding_structure">
  <head>Document Structure</head>
  <div xml:id="encoding_structure_headings">
    <head>Headings</head>
    <p>Headings appear at the beginning of an item, usually giving a
    title ascribed by Forbes. Not all items have headings—most do, but
    there are notable exceptions, especially in the later volumes of the
    manuscript.</p>
    <p>To encode the heading of a document, use the
    <gi>head</gi> element:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
 <head>Copy of a Letter to Mr
    <lb/>Robert Forbes at My Lady
    <lb/>Bruce's Lodgings at Leith.
 </head>
</egXML>
    <p>Since headings appear inconsistently across the document
    collection and are often styled differently, any renditional
    information about the heading (i.e. size or alignment) must be
    specified using the <att>rendition</att> attribute. For
    instance, consider the heading for "Copy of a Letter to Mr
    Robert Forbes at My Lady Bruce's Lodgings at Leith":</p>
    <p><figure>
      <figDesc>Example from v01.0070.01</figDesc>
      <graphic url="images/encoding_heading_example.png"/>
    </figure></p>
    <p>The heading here is both in larger writing and aligned to the
    right, which we can describe by using the "rnd:right" and
    "rnd:large" values on
    <att>rendition</att>:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
 <head rendition="rnd:right rnd:large">Copy of a Letter to Mr
    <lb/>Robert Forbes at My Lady
    <lb/>Bruce's Lodgings at Leith.
 </head>
</egXML>
  </div>
  <div xml:id="encoding_structure_paragraphs">
    <head>Paragraphs</head>
    <p/>
  </div>
  <div xml:id="encoding_structure_openers-and-closers">
    <head>Openers and Closers</head>
    <p>Openers and closers refer to material that tend to begin or
    conclude a letter.</p>
    <specList>
        <specDesc key="opener"/>
        <specDesc key="closer"/>
        <specDesc key="salute"/>    
        <specDesc key="dateline"/>
        <specDesc key="postscript"/>    
    </specList>
    <p>Letters often conclude with various features that we want to tag,
    including closers with signatures and datelines; postscripts; and
    trailing notes written by Forbes.</p>
    <p><figure>
      <figDesc>Example structure of a closer</figDesc>
      <graphic url="images/letter-closer-diagram.png"/>
    </figure></p>
    <p>The above would be encoded like so:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
 <p> 
    <!-- [Paragraph begins on the previous page] -->
      <lb/><choice><orig>ther</orig><reg>there</reg></choice> are not one sentence therein <w>Con<pc force="weak">-</pc>
    <lb/>tained</w> but Real truth this with my
    <lb/>blessing <choice><orig>wising</orig><reg>wishing</reg></choice> you all <choice><orig>maner</orig><reg>manner</reg></choice> of <choice><orig><w>happy<pc force="weak">-</pc>
    <lb/>ness</w></orig><reg>happiness</reg></choice> 
</p>
<closer rendition="rnd:two-column">
    <signed rendition="rnd:right">I am <choice><abbr>Dr</abbr><expan>Dear</expan></choice> Sir your most <choice><orig><w>affac<pc force="weak">-</pc>
        <lb/>tionat</w></orig><reg>affectionate</reg></choice> humble <choice><abbr>sert</abbr><expan>servant</expan></choice>
        <lb/>Sic subr <persName ref="prs:LEITA1"><choice><orig>Ane</orig><reg>Anne</reg></choice> Leith</persName>
    </signed>
    <dateline rendition="rnd:left"><placeName ref="plc:INVE2">Inverness</placeName>  
    <lb/>March 29 1749</dateline>
</closer>
<milestone rendition="rnd:right" type="rule" unit="section"/>
<postscript>
    <p>p s this being the <choice><orig>shurest</orig><reg>surest</reg></choice> <choice><orig>berer</orig><reg>bearer</reg></choice> I Could
    <lb/>get in the world <choice><orig>mad</orig><reg>made</reg></choice> me write
    <lb/>those sheets with the greater <choice><orig>hury</orig><reg>hurry</reg></choice>
    <lb/><choice><orig>therefor</orig><reg>therefore</reg></choice> I <choice><orig>hop</orig><reg>hope</reg></choice> <choice><orig>youl</orig><reg>you'll</reg></choice> excuse Errors
    </p>
</postscript>
<milestone unit="section" type="rule"/>
<note type="lim" place="bottom" anchored="false">N: B: The Originals of the two <w>pre<pc force="weak">-</pc>
    <lb/>ceeding</w> Letters &amp; of the <w>Narra<pc force="weak">-</pc>
    <lb/>tive</w> from <persName ref="prs:LEITA1">Mrs Leith</persName> are to be
    <lb/>found among my Papers.</note>
    <closer>
        <signed rendition="rnd:right rnd:large rnd:bordered-bottom-dashed">Robert Forbes, A:M:</signed>
    </closer>
</egXML>
    <div xml:id="encoding_structure_two-column-closers">
      <head>Two Column Closers</head>
      <p>Closers often feature a two-column structure (as above) where
      the <gi>dateline</gi> is floated to the left
      and the <gi>signed</gi> is to the right. To
      encode the two column layout, set the
      <att>rendition</att> of the
      <gi>closer</gi> to
      <code>rnd:two-column</code> and then use
      <code>rnd:left</code> for the block floated to the left
      and <code>rnd:right</code> for the block floated to the
      right. For instance, the above</p>
    </div>
  </div>
  <div xml:id="encoding_structure_verse">
    <head>Verse</head>
    <p>Poems and other verse fragments should be encoded using the
    following elements for verse:</p>
    <specList>
        <specDesc key="l"/>
        <specDesc key="lg"/>
    </specList>
    <p>All <gi>l</gi> elements should be enclosed
    within an <gi>lg</gi>; note that you do not
    need to include a line beginning element for verse lines.</p>
    <p>For poems with headings, use the
    <gi>head</gi> element inside of the
    <gi>lg</gi></p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<lg>
    <head rendition="rnd:center">1.</head>
    <l>As the Devil was walking o’er Britain’s fair Isle,</l>
    <l>George spied in his Phiz a particular Smile,</l>
    <!--[...]-->
</lg>
</egXML>
    <p>Indented lines should be encoded using
    <att>rendition</att> with the value
    "rnd:indent".</p>
  </div>
</div>

<div xml:space="preserve" xml:id="encoding_notes">
  <head>Notes and Annotations</head>
  <p>Notes and annotations refer to any kind of textual component that
  serve as, or cause, some sort of intervention within the main flow of
  the text, appearing virtually anywhere through the document. Often,
  notes are used by Forbes (or others) to provide some additional
  hypertextual information to supplement that main text; this is in
  contrast to <ref target="transcribing_edition.md">additions and
  deletions</ref> (tagged using <gi>add</gi> and
  <gi>del</gi>), which modify the main content of
  the text.</p>
  <p>This page describes how to encode notes that appear within the
  primary source text and not notes written by the LiM team (see
  <ref target="#editorial_notes">Editorial Notes</ref> for instructions
  on encoding editorial notes). In all cases, we use the
  <gi>note</gi> element for encoding the main
  content of the note with a <att>type</att> value of
  "lim." Further information on other attributes used to
  differentiate the placement, position, and function of these notes are
  described in the following.</p>
  <div xml:id="encoding_notes_note-content">
    <head>Note Content</head>
    <p>All notes must have <hi rendition="simple:italic">structured
    content</hi>, meaning that it must contain, at minimum, a child
    <gi>p</gi> element. This is not a required by
    the TEI, but makes processing and handling for the note much more
    straightforward. (This decision, and much of the modelling for
    notes, has been inspired by <hi rendition="simple:italic">The Women
    Writers Project's Guide to Scholarly Text Encoding</hi>, especially
    their discussion of
    <ref target="https://wwp.northeastern.edu/research/publications/guide/html/notes_outline.html">"Notes
    and Annotations"</ref>)</p>
    <p>In most cases, this means that even a short note--like a
    cross-reference--will contain a paragraph:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<note type="lim" place="above">
<p>See p. <ref target="pg:524">524</ref>.</p>
</note>
</egXML>
    <p>ALl other transcribing conventions apply within a
    <gi>note</gi>; if there are page beginnings or
    formeworks, encode those as you would normally.</p>
  </div>
  <div xml:id="encoding_notes_footnotes">
    <head>Footnotes</head>
    <p>The most common kind of note in Forbes is a footnote, which
    consists of three things:</p>
    <list type="ordered:arabic">
      <item>
        <p>A note marker in the text (e.g. a cross)</p>
      </item>
      <item>
        <p>A corresponding marker found elsewhere that refers to the one
        in the text</p>
      </item>
      <item>
        <p>The content of the annotation</p>
      </item>
    </list>
    <p>Our encoding of these notes is to make the relationship between
    the note and the text explicit by providing links between the note
    marker in the text with the note itself.</p>
    <div xml:id="encoding_notes_encoding-the-note-marker">
      <head>Encoding the note marker</head>
      <p>Note markers found within the text (i.e. the symbol that refers
      to the note) are tagged using the custom
      <gi>noteMarker</gi> element, bearing an
      <att>xml:id</att> and a
      <att>ref</att>:</p>
      <specList>
          <specDesc key="noteMarker" atts="xml:id ref"/>
      </specList>
      <p>In the majority of cases, the
      <gi>noteMarker</gi> will have no content
      (i.e. it is a self-closing element:
      <gi>noteMarker/</gi>); to describe the
      symbol (or "glyph"), use the <att>ref</att>
      attribute to point to the centralized definition of the glyphs we
      have compiled. The list of available glyphs is below:</p>
      <divGen xml:id="glyph_list"/>
      <p>In this case, the symbol is a cross, so it would be encoded
      like so:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<noteMarker ref="g:cross"/>
</egXML>
      <p>If the symbol you're attempting to encode is not on the list,
      use the value <code>g:UNKNOWN</code> in the
      <att>ref</att> and then place the best approximation
      of the symbol you can find inside of the
      <gi>noteMarker</gi> element:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<noteMarker ref="g:UNKNOWN">☃</noteMarker>
</egXML>
      <p>Put a (initialed) XML comment inside of the noteMarker element
      as well to describe to future encoders what you found; we will
      want to add this symbol to our list of glyphs as we proceed:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<noteMarker ref="g:UNKNOWN">☃<!--JT: Forbes used a snowman, for some reason?--></noteMarker>
</egXML>
      <p>Note markers must also contain a unique identifier using the
      <att>xml:id</att> attribute. The
      <att>xml:id</att> should being with a "p",
      followed by the page number, an underscore, an "n", and
      a number. For example:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<noteMarker ref="g:cross" xml:id="p242_n1"/>
</egXML>
    </div>
    <div xml:id="encoding_notes_encoding-the-note">
      <head>Encoding the Note</head>
      <p>Encode the content of the note as it appears on the page.
      Usually, this is at the bottom of the page either preceding or
      following the catchword; notes tend to be grouped together at the
      bottom of the page and separated from the main content with a
      horizontal line, which should be encoded according to
      <ref target="encoding_common.md#encoding_common_horizontal-rules">Common
      Bibliographical/Structural Features</ref>.</p>
      <p>Footnotes should be tagged using a
      <gi>note</gi> element with a
      <att>type</att> = "lim" and
      <att>anchored</att> = "true".</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<milestone unit="section" type="rule"/>
<note type="lim" anchored="true">
<!--Note content...-->

</note>
</egXML>
      <p>All anchored notes must begin with a
      <gi>noteMarker</gi> with a
      <att>target</att> attribute that points to the id (or
      ids) of the note markers you encoded earlier. In XML, you can
      point to an id by first putting a '#' and then the id. For
      instance, in the above example, the cross has an
      <att>xml:id</att> = "p242_n1". For the
      corresponding note, we do the following:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<note type="lim" anchored="true">
<noteMarker ref="g:cross" target="#p242_n1"/>
<!--More content here-->
</note>
</egXML>
      <p>Make sure to use the same <att>ref</att> value
      from the earlier note (and, if the value was
      <code>g:UNKNOWN</code>, then place the same content
      inside of the <gi>noteMarker</gi>).</p>
      <p>In some cases, a single symbol will refer to multiple points in
      the text. To encode multiple points of attachment, separate each
      <att>target</att> value with a space:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<note type="lim" anchored="true">
<noteMarker ref="g:cross" target="#p525_n1 #p525_n3 #p525_n4"/>
</note>
</egXML>
      <p>If a note has multiple symbols, then encode each symbol and its
      target separately within a single
      <gi>note</gi>. For example:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<note type="lim" anchored="true">
    <noteMarker ref="g:cross" target="#p530_n1"/>
    <noteMarker ref="g:x" target="#p530_n2"/>
    <p>Vol: 1. p: <ref target="pg:195">195</ref>.</p>
</note>
</egXML>
      <p>Here is another example of a note with multiple targets and
      multiple symbols:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<note type="lim" anchored="true">
    <noteMarker ref="g:cross" target="#p525_n1 #p525_n3"/>
    <noteMarker ref="g:x" target="#p525_n2"/>
    <p>Vol: 1. p: <ref target="pg:187">187</ref>, <ref target="pg:194">194</ref>. Vol: 2. p: <ref target="pg:304">304</ref>, <ref target="pg:305">305</ref>.</p>
</note>
</egXML>
    </div>
  </div>
  <div xml:id="encoding_notes_unanchored-notes">
    <head>Unanchored Notes</head>
    <p>Unanchored notes (i.e. floating or marginal notes) should be
    encoded using the <gi>note</gi> element with
    an <att>type</att> value of "lim" and an
    <att>anchored</att> value of "false". They
    should be encoded where (or close to where) they appear in the text.
    It is often difficult to pinpoint precisely where a note should go,
    but in most cases, you can use your best judgement for positioning
    the marginal note.</p>
    <p>For position the note, use the <att>place</att>
    attribute with one or more of the following values:</p>
    <divGen xml:id="place_list"/>
  </div>
  <div xml:id="encoding_notes_nota-benes">
    <head>Nota Benes</head>
    <p>Forbes' NBs are a special case. While they are nominally
    "notes," in practice, they function similarily to other
    structural features of a text (such as a postscript, closer, et
    cetera): they can appear both in the main stream of text as well as
    within notes (either comprising the entirety or only a portion of
    the note) and often have their own set of footnotes.</p>
    <p>Given the complexity and structural significance of Forbes' NBs,
    they have their own dedicated element in the LiM Schema:
    <gi>NB</gi>:</p>
    <specList>
    <specDesc key="NB"/>
    </specList>
    <p><gi>NB</gi>s that are part of the regular
    textual flow (i.e. as a separate paragraph or set of paragraphs at
    the end of an item) should simply wrap the paragraph:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
         <closer rendition="rnd:right"> <salute><choice><orig>adew</orig><reg>adieu</reg></choice></salute>
            <signed><foreign xml:lang="la">Sic subr</foreign> Anne Leith</signed>
         </closer>
         <NB>
            <p>N:B: The Original of the
               <lb/>Above is to be found 
               <lb/>among my Papers.</p>
            <closer>
               <signed rendition="rnd:bordered-bottom-dashed">Robert Forbes A:M:</signed>
            </closer>
         </NB>
</egXML>
    <p>When an NB appears within a marginal note or a footnote, encode
    the <gi>NB</gi>
    <hi rendition="simple:italic">within</hi> the
    <gi>note</gi>:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<note type="lim" place="right">
    <NB>
        <p>P. 424</p>
        <signed>Robert Forbes A:M:</signed>
    </NB>
</note>
</egXML>
  </div>
</div>

<div xml:space="preserve" xml:id="transcribing_editing">
  <head>Item Content and Transcription</head>
  <div xml:id="transcribing_editing_abbreviations-and-expansions">
    <head>Abbreviations and Expansions</head>
    <div xml:id="transcribing_editing_common-abbreviations-the-that-ampersands">
      <head>Common abbreviations: the, that, ampersands</head>
      <p>For common abbreviations like "yt" for
      "that", "ye" for "the" that appear
      often throughout the text, you do not need to use
      <gi>choice</gi> or
      <gi>expan</gi>; instead, you can simply tag
      the abbreviation using the <gi>abbr</gi> tag
      with a <att>type</att> value with the correct
      word:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<abbr type="the">ye</abbr>
</egXML>
      <p>In most cases, ampersands <hi rendition="simple:italic">do
      not</hi> need to be tagged at all--they will be automatically
      expanded in processing. However, do note that ampersands are
      special characters in XML and cannot be represented simply by the
      &amp; character and must be typed in as
      <code>&amp;amp;</code></p>
      <p>However, if the ampersand does not expand to "and",
      then you must tag the abbreviation using the full
      <gi>choice</gi>,
      <gi>abbr</gi>, and
      <gi>expan</gi> method below:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<choice><abbr>&amp;c.</abbr><expan>et cetera</expan></choice>
</egXML>
      <divGen xml:id="abbrTable"/>
    </div>
    <div xml:id="transcribing_editing_uncommon-abbreviations">
      <head>Uncommon abbreviations</head>
      <p>Uncommon or unfamiliar abbreviations—like Revd—will often need
      to be expanded in order to provide clarity and to facilitate
      searching. To do so, first tag the abbreviation with the
      <gi>abbr</gi> element, then tag your
      expansion with an <gi>expan</gi>, and then
      wrap both in a <gi>choice</gi> element. For
      example:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<title>Letter from the <choice><abbr>Revd.</abbr><expan>Reverend</expan></choice> Mr. <persName>Lyon</persName></title>
</egXML>
    </div>
    <div xml:id="transcribing_editing_expanding-hyphenated-words">
      <head>Expanding Hyphenated Words</head>
      <p>Hyphenated words (i.e. words tagged with
      <gi>w</gi>) may also need to be expanded; in
      this case, just wrap the <gi>w</gi> in an
      <gi>abbr</gi> and then use a
      <gi>choice</gi> and
      <gi>expan</gi> as above:</p>
    </div>
  </div>
  <div xml:id="transcribing_editing_supplying-regularizing-and-flagging-incorrect-text">
    <head>Supplying, Regularizing, and Flagging Incorrect Text</head>
    <p>Since the LiM represents multiple voices, we need to be explicit
    in our signalling of our editorial interventions and judicious in
    our appraisal of what kind of intervention we need to make.</p>
    <p>There are three situations where editorial intervention is
    necessary:</p>
    <list type="ordered:arabic">
      <item>
        <p>Text that must be supplied due to obscured page images, ink
        blots, or other obfuscating factors</p>
      </item>
      <item>
        <p>Non-normative spelling that we want to regularize for
        searching purposes</p>
      </item>
      <item>
        <p>Obvious errors</p>
      </item>
    </list>
    <p>This list is in order of descending preference; in most cases, it
    is too difficult to determine if something is truly an
    "error" that can and should be corrected.</p>
    <div xml:id="transcribing_editing_supplying-text">
      <head>Supplying Text</head>
      <p>Tag text that has been obscured in some way (usually lost in
      the margin or the fold of the book) using the
      <gi>supplied</gi> tag:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<lb/><supplied>I</supplied>rons upon him, which he looked upon
</egXML>
      <p>If you are not certain about the supplied text, then use the
      <att>cert</att> attribute on
      <gi>supplied</gi> with a value of
      <code>low</code>:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
provided that he
<lb/><supplied cert="low">w</supplied>ould not sit down, but come out as
</egXML>
    </div>
    <div xml:id="transcribing_editing_regularizing-text">
      <head>Regularizing Text</head>
      <p>Tag cases where a word differs from its normative form or
      spelling and would benefit from regularization to help with
      searching by tagging the original word using
      <gi>orig</gi>, the regularized version using
      <gi>reg</gi>, and wrapping both in a
      <gi>choice</gi> element:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
I had some share the effects of <choice><orig>wich</orig><reg>which</reg></choice> 
</egXML>
      <p>Note that the names of people, places, organizations, and
      objects <hi rendition="simple:italic">should not</hi> be
      regularized. Since all people, places, and organizations will be
      tagged and associated with an person, place, or organization
      entity, it is unnecessary to regularize these proper names.</p>
    </div>
    <div xml:id="transcribing_editing_corrections">
      <head>Corrections</head>
      <p>While we do not correct erroneous text, we do flag instances
      where the word or phrase seems incorrect in some way by using the
      <gi>sic</gi> tag:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
 <lb/>of Distinction, wait <sic>of</sic> General
</egXML>
    </div>
  </div>
  <div xml:id="transcribing_editing_additions-deletions-and-substitutions">
    <head>Additions, Deletions, and Substitutions</head>
    <p>Additions and deletions in text may appear in the text either in
    isolation or as part of a single textual event.</p>
    <div xml:id="transcribing_editing_additions">
      <head>Additions</head>
      <p>In all cases, additions should be marked with the
      <gi>add</gi> tag with its location encoded
      using the <att>place</att> attribute. For
      example:</p>
      <p><figure>
        <figDesc>Example from v02.0221.01</figDesc>
        <graphic url="images/addition_example.png"/>
      </figure></p>
      <p>In this case, text has been added above the line, which would
      be encoded like so:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<lb/>Donell, <add place="above">George Moir the</add> Laird of Leckie,
</egXML>
      <p>Here, we can also tag the "George Moir the Laird of
      Leckie" as a <gi>persName</gi> and
      point to his <att>xml:id</att>:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<lb/>Donell, <persName ref="prs:MOIRG1"><add place="above">George Moir the</add> Laird of Leckie</persName>
</egXML>
    </div>
    <div xml:id="transcribing_editing_deletions">
      <head>Deletions</head>
      <p>Tag text that has been marked for deleting using the
      <gi>del</gi> element:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<title>Written in <del>in</del> April</title>
</egXML>
      <p>If the deletion has obscured the text such that it makes the
      text difficult (but not impossible) to transcribe, nest the
      <gi>unclear</gi> tag within the
      <gi>del</gi>; as above, add an editorial
      note if warrants further explanation or clarification is needed
      (note, however, that the <gi>note</gi> is
      beside the <gi>del</gi> element):</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<title>While I pondered weak and <del><unclear>wary</unclear></del><note type="editorial">Possibly <mentioned>weary</mentioned>.</note></title>
</egXML>
      <p>If the text is rendered completely illegible, then use a
      <gi>gap</gi> element with an explanatory
      <gi>desc</gi> within the
      <gi>del</gi>:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<title>While I pondered weak and <del><gap><desc>Illegible</desc></gap></del></title>
</egXML>
    </div>
    <div xml:id="transcribing_editing_substitutions">
      <head>Substitutions</head>
      <p>When an addition and deletion are related (i.e. the additional
      text should take the place of the deleted text), then we can
      encode that relationship by wrapping the
      <gi>add</gi> and
      <gi>del</gi> with the substitution element
      <gi>subst</gi>. For example:</p>
      <p><figure>
        <figDesc>Example from v02.0221.01</figDesc>
        <graphic url="images/substitution_example.png"/>
      </figure></p>
      <p>The substitions are highlighted above; in each case, there is a
      deletion (with illegible content) and an addition above. In the
      first example, we would encode the additional "some"
      using the <code>add</code> element:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<add place="above">some</add>
</egXML>
      <p>and the deleted word using <gi>del</gi>
      with a nested <gi>gap</gi> that examples the
      extent of the cancelled text:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<del><gap reason="deleted" quantity="1" unit="word"/></del>
</egXML>
      <p>To signal that these are a related substitution, we wrap the
      <code>add</code> and the <code>del</code> in a
      <gi>subst</gi>. So putting this all
      together:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<subst><add place="above">some</add><del><gap reason="deleted" quantity="1" unit="word"/></del></subst>
</egXML>
    </div>
    <div xml:id="transcribing_editing_unclear-text">
      <head>Unclear Text</head>
      <p>Tag text that you are unable to transcribe text that is
      partially obscured for some reason (illegible writing, scan is
      missing or incompletel, external damage like ink smudges, etc)
      using the <gi>unclear</gi> element:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<unclear>MacDonald</unclear>
</egXML>
      <p>If you'd like to expand on what is unclear, or possible other
      readings, then add a note beside the
      <gi>unclear</gi> using the
      <gi>note</gi> element with
      <att>type</att>=<val>editorial</val></p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<unclear>MacDonald</unclear> <note type="editorial">Quite likely MacDonald, but could also be McDonald.</note>
</egXML>
      <p>If you are unable to transcribe the text at all or the text has
      been removed completely (i.e. the page is burnt; the text is cut
      off in the facsimile), use the <gi>gap</gi>
      element with an explanatory
      <gi>desc</gi>:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
<gap><desc>First six words illegible due to scan.</desc></gap>
</egXML>
    </div>
  </div>
  <div xml:id="transcribing_editing_elisions-and-omissions">
    <head>Elisions and Omissions</head>
    <p>Text that has been purposefully omitted/elided by Forbes (e.g.
    for political or social reasons) should be tagged using the
    <gi>ellipsis</gi> element in combination with
    a <gi>metamark</gi> and, if the omitted text
    is known, a <gi>supplied</gi>. Consider the
    following line from "Copy of a Letter to Captain Malcolm
    MacLeod of Castle in Raaza" (v02.0323.01):</p>
    <p><figure>
      <figDesc>Example from v02.0323.01</figDesc>
      <graphic url="images/ellipsis_example.png"/>
    </figure></p>
    <p>First, the gap between the "R" and "on" would
    be marked as an omission using the
    <gi>ellipsis</gi> element like so:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
He said, in the Event of a R<ellipsis><!--...--></ellipsis>on,
</egXML>
    <p>This tells us that there is text that has been elided; to encode
    the space, we use a <gi>metamark</gi> with a
    child <gi>space</gi> element within the
    <gi>ellipsis</gi>:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
He said, in the Event of a R<ellipsis><metamark><space/></metamark></ellipsis>on,
</egXML>
    <p>Note that the <gi>metamark</gi> element
    allows you to use either a <gi>space</gi>
    element <hi rendition="simple:italic">or</hi> text content (but not
    both); if, for instance, the elision was signaled using em-dashes
    (i.e. "Mr. F———"), then you would put the "———"
    as the text value of the
    <gi>metamark</gi>:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
I went to the store with Mr. F<ellipsis><metamark>———</metamark></ellipsis>
</egXML>
    <p>To add the supplied text, place a
    <gi>supplied</gi> after the
    <gi>metamark</gi> like so. Make sure to use a
    <att>resp</att> that points to your team ID to credit
    yourself; if you are uncertain about your interpretation, you can
    use a <att>cert</att> (as described above) with a value
    of "low":</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
He said, in the Event of a R<ellipsis><metamark><space/></metamark><supplied resp="team:JT1" cert="low">estoration</supplied></ellipsis>
</egXML>
    <div xml:id="transcribing_editing_elisions-multiple-choices-prince-vs-pretender">
      <head>Elisions: Multiple Choices (Prince vs Pretender)</head>
      <p>In cases of an initial P with a set of spaces (which can be
      either Prince or Pretender), place a
      <gi>choice</gi> within the
      <gi>supplied</gi> with a
      <gi>seg</gi> for each "rince" and
      "retender" like so:</p>
      <egXML xmlns="http://www.tei-c.org/ns/Examples">
If The P<ellipsis>
  <metamark><space/></metamark>
  <choice>
     <seg>rince</seg>
     <seg>retender</seg>
  </choice>
</ellipsis> returns...
</egXML>
    </div>
  </div>
  <div xml:id="transcribing_editing_foreign-language">
    <head>Foreign Language</head>
    <p>To tag that something is in a foreign language, use the
    <att>xml:lang</att> attribute with an ISO language tag
    value for that language:</p>
    <divGen xml:id="language_list"/>
    <p>How and where you attach that <att>xml:lang</att>
    depends on whether the segment of foreign language is entirely
    contained by a single element. For instance, if an entire
    <gi>title</gi> in an
    <gi>item</gi> is in French, then you can place
    the <att>xml:lang</att> directly on the
    <gi>item</gi>:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<item><title xml:lang="fr">Le petit chien</title></item>
</egXML>
    <p>If the foreign language appears has no logical wrapper (i.e. a
    single foreign phrase in a sentence or a foreign word), then use the
    <gi>foreign</gi> element:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<item><title>This example was created <foreign xml:lang="la">ex nihilo</foreign></title></item>
</egXML>
  </div>
  <div xml:id="transcribing_editing_multiple-hands">
    <head>Multiple Hands</head>
    <p>Annotations in different hands—i.e. additions written in a
    different medium by another scribe—can be encoded using the
    <att>hand</att> attribute in concert with the
    <gi>handNotes</gi> element in the
    <gi>teiHeader</gi>.</p>
    <p>Hands are not centralized, so each distinct hand encountered in a
    file needs to be encoded in the
    <gi>teiHeader</gi>. Specifically, the
    <gi>handNotes</gi> and
    <gi>handNote</gi> element should appear in the
    <gi>profileDesc</gi>, below the
    <gi>limItem</gi> element:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
 <profileDesc>
    <limItem>
      <!--Lots of metadata here...-->
    </limItem>
    <!--Add a handNotes and handNote element here-->
    <handNotes>
        <handNote/>
    </handNotes>
 </profileDesc>
</egXML>
    <p>Encode each distinct hand in the document using the
    <gi>handNote</gi> element, which must contain
    an <att>xml:id</att> and a
    <att>medium</att>:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<handNotes>
   <handNote xml:id="hand_pencil" medium="pencil">Unknown hand in pencil</handNote>
</handNotes>
</egXML>
    <p>If you know the scribe, use the <att>scribeRef</att>
    attribute to denote to whom the hand belongs:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<handNote xml:id="hand_crayon" medium="crayon" scribeRef="pers:BLOGJ1">Hand in crayon, likely J. Bloggs.</handNote>
</egXML>
    <p>Once the <gi>handNote</gi> is encoded, use
    the <att>hand</att> attribute to point to the
    <att>xml:id</att> of the
    <gi>handNote</gi>:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<!--In the teiHeader-->
<teiHeader>
<!-- [...] -->
    <profileDesc>
        <limItem>
            <!--[...]-->
        </limItem>            
         <handNotes>
            <handNote xml:id="hand_pencil" medium="pencil">Unknown hand in pencil</handNote>
        <handNote xml:id="hand_crayon" medium="crayon" scribeRef="pers:BLOGJ1">Hand in crayon, likely J. Bloggs.</handNote>
         </handNotes>
    </profileDesc>
    <!--[...]-->
</teiHeader>
<text>
    <body>
        <!--[...]-->
        <add hand="#hand_pencil">Bogue</add>
        <!--[...]-->
        <note type="lim" anchored="false" hand="#hand_crayon">
            <p>[...]</p>
        </note>
    </body>
</text>
</egXML>
  </div>
</div>

<div xml:space="preserve" xml:id="people_places">
  <head>Tagging People, Places, etc in Transcriptions</head>
  <p>People, places, and other named entities are tagged in a similar
  fashion: each name is tagged using a distinguishing tag with an
  <att>ref</att> attribute that points to the associated
  id. They also share a set of common rules:</p>
  <list type="unordered">
    <item>
      <p>They must not begin or end with spaces</p>
    </item>
    <item>
      <p>They must use the <att>ref</att> to refer to the
      entity's record</p>
    </item>
    <item>
      <p>They can contain phrase- and word-level elements (i.e.
      <gi>choice</gi>,
      <gi>add</gi>,
      <gi>supplied</gi>, etc)</p>
    </item>
    <item>
      <p>They cannot nest: i.e. do not put a
      <gi>placeName</gi> inside of a
      <gi>persName</gi>.</p>
    </item>
  </list>
  <div xml:id="people_places_contributors">
    <head>Contributors</head>
    <p>To create a New Contributor, right click on the “contributors”
    folder, and then select “New” and then “File”. <figure>
      <figDesc>image10</figDesc>
      <graphic url="images/1.10.png"/>
    </figure></p>
    <p>Select the “templates” folder, and then click on “New Team
    Member/ Contributor Document”. Change the file names to the author’s
    initials (eg. SJI.xml). <figure>
      <figDesc>image11</figDesc>
      <graphic url="images/1.11.png"/>
    </figure></p>
    <p>To edit a template, replace the green text (the XML Comment) with
    your text. For instance, edit the forename, surname and display
    name. <figure>
      <figDesc>image12</figDesc>
      <graphic url="images/1.12.png"/>
    </figure></p>
  </div>
  <div xml:id="people_places_people">
    <head>People</head>
    <p>Direct references to people should be tagged using the
    <gi>persName</gi> element that uses the
    <att>ref</att> attribute to point to the person's id
    using the special <val>prs:</val> prefix.
    For instance:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<persName ref="prs:1">Mr. Lyon</persName>
</egXML>
    <p>Where <val>prs:1</val> refers to the
    person's id in the person database/spreadsheet.</p>
    <p>As mentioned above, personal names should include any honourifics
    or titles, which may be editorially expanded:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<persName ref="prs:1"><choice><abbr>Revt.</abbr><expan>Reverend</expan></choice> Mr. Lyon</persName>
</egXML>
    <p>Do not use <gi>persName</gi> to tag
    indirect references to people—e.g. The King; His mother; That Guy—as
    these are not personal names, but references to a person. In these
    cases, instead of <gi>persName</gi>, use the
    <gi>rs</gi> (referring string) element with
    <att>type</att>=<val>person</val>
    alongside the <att>ref</att> attribute that points to
    the person. For instance:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<rs type="person" ref="prs:3">his mother</rs>
</egXML>
    <p>Groups of people that are not organizations (i.e. Parliament) or
    anonymous groups (the audience) can be tagged as if they are a
    single person:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<rs type="person" ref="prs:4">Sisters</rs>
</egXML>
    <p>The above examples all derive from the first item of vol11_vol1;
    here is what it looks in its entirety:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<title>Letter from the <persName ref="prs:1"><choice><abbr>Revt.</abbr><expan>Reverend</expan></choice> Mr. <persName>Lyon</persName></persName> to <rs type="person" ref="prs:3">his mother</rs><choice><abbr>+</abbr><expan>and</expan></choice><rs type="person" ref="prs:4">Sisters</rs></title>
</egXML>
  </div>
  <div xml:id="people_places_places">
    <head>Places</head>
    <p>See summary below.</p>
  </div>
  <div xml:id="people_places_events">
    <head>Events</head>
    <p>TODO</p>
  </div>
  <div xml:id="people_places_objects">
    <head>Objects</head>
    <p>TODO</p>
  </div>
</div>

<div xml:space="preserve" xml:id="encoding_dates_times">
  <head>Encoding Dates and Times</head>
  <p>This document describes the protocol for encoding dates and times
  within transcriptions.</p>
  <p>Note that you should only encode
  <hi rendition="simple:italic">real</hi> dates and
  <hi rendition="simple:italic">real</hi> times; in other words, we are
  interested in identifying specific points in time and not broad or
  general references to time.</p>
  <div xml:id="encoding_dates_times_dates">
    <head>Dates</head>
    <p>Use the <gi>date</gi> element to encode
    dates; the date (in YYYY-MM-DD format) should be encoded using the
    <att>when</att> attribute:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
I was in Switzerland in the year
<lb/><date when="1734">1734</date>.
</egXML>
    <p>Tag only the minimum information necessary for the date. For
    instance, in the following <gi>dateline</gi>,
    you would only encode the "Augt 18th, 1746" part of the
    date, even though there is additional information:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<dateline>
Upon Tower-hill, Monday, <date when="1746-08-18">Augt
<lb/>18th, 1746</date>. in the 58th year
<lb/>of his Age.</dateline>
</egXML>
    <p>For a date range, use the <att>from</att> and
    <att>to</att> attributes:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
I travelled to Geneva from <date from="1746-08-18" to="1746-09-03">August 18, 1746 to September 3</date>
</egXML>
    <p>For uncertain date ranges, use the
    <att>notBefore</att> and
    <att>notAfter</att> attributes (NB: this isn't very
    common within text transcriptions, but is frequently necessary for
    person record when describing dates of birth or residence).</p>
  </div>
  <div xml:id="encoding_dates_times_times">
    <head>Times</head>
    <p>Times follow similar rules to dates: encode the time using the
    <gi>time</gi> element.</p>
    <p>Each time must contain a <att>when</att> attribute
    that specifies the time in the 24 hour clock in the format HH:MM:SS
    (i.e. 4:15pm would be encoded as 16:15:00). For example:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
About <time when="11:00:00">eleven o’Clock</time> He ordered them
            <lb/>to refresh themselves by Sleep
</egXML>
    <p>Each time must include hours, minutes, and seconds (even though
    it will be rare for seconds to be specified in the text).</p>
    <p>When both a time and date are combined, use the
    <gi>date</gi> element to encode the entire
    phrase and tag the <code>&lt;time</code>&gt; within the
    date:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
About <date when="1746-04-16"><time when="02:00:00">2 o’Clock of the <w>Morn<pc force="weak">-</pc>
            <lb/>ing</w></time> of the 16<hi rendition="rnd:underlined">th</hi></date>
</egXML>
  </div>
</div>
</div>
<div xml:space="preserve" xml:id="facsimiles">
  <head>Encoding Facsimiles</head>
  <p>The metadata for the facsimiles for each volume is contained within
  a separate file in the volume's data directory (e.g. the facsimile
  file for volume 1 is located in
  <code>data/volumes/vol01/vol1_facs.xml</code>). The
  facsimile file for each volumes contains information about various
  pagination schemes as well as pointing to the facsimile image file in
  SFU's Islandora collection. This information was originally compiled
  from a spreadsheet and should be edited with caution to avoid breaking
  any links to the page images.</p>
  <p>The <gi>facsimile</gi> element contains all
  of the information about the pages with a
  <att>corresp</att> pointing to the Islandora collection
  landing page:</p>
  <egXML xmlns="http://www.tei-c.org/ns/Examples">
<facsimile corresp="islandora:4593">
    <!-- ... -->
</facsimile>
</egXML>
  <p>Within the <gi>facsimile</gi>, each page is
  represented by a <gi>surface</gi>, which at
  minimum contains an <att>xml:id</att> to provide an
  identifier. All pages that have a digital representation (i.e. not
  missing or lost pages), also contain a
  <gi>graphic</gi> that points to the Islandora
  PID.</p>
  <egXML xmlns="http://www.tei-c.org/ns/Examples">
 <surface n="1" xml:id="vol1_001">
     <graphic url="islandora:4806"/>
 </surface>
</egXML>
  <p>Paratextual pages (i.e. front covers, etc) are direct children of
  the <gi>facsimile</gi> and contain a
  <gi>desc</gi> that describes the page:</p>
  <egXML xmlns="http://www.tei-c.org/ns/Examples">
     <surface n="1" xml:id="vol1_001">
         <graphic url="islandora:4806"/>
         <desc>front cover</desc>
      </surface>
</egXML>
  <p>For pages that are part of the manuscript proper, we group the
  pages into folios (i.e. front and back) in order to capture the
  National Library of Scotland's folio number. Each
  <gi>surface</gi> within a
  <gi>surfaceGrp</gi> is categorized as
  "recto" or "verso" through the
  <att>type</att> attribute. Since there are multiple
  pagination schemes for the manuscript, each
  <gi>surface</gi> also contains a set of
  <gi>milestone</gi>s that specify the page number
  under a specific counting system. For instance:</p>
  <egXML xmlns="http://www.tei-c.org/ns/Examples">
    <surfaceGrp n="1">
         <surface n="7" xml:id="vol2_007" type="recto">
            <graphic url="islandora:4783"/>
            <milestone unit="page" type="Forbes" n="199"/>
            <milestone unit="page" type="volume" n="1"/>
            <milestone unit="page" type="collection" n="199"/>
         </surface>
         <surface n="8" xml:id="vol2_008" type="verso">
            <graphic url="islandora:4782"/>
            <milestone unit="page" type="Forbes" n="200"/>
            <milestone unit="page" type="volume" n="2"/>
            <milestone unit="page" type="collection" n="200"/>
         </surface>
      </surfaceGrp>
</egXML>
  <p>This encoding says the following:</p>
  <list type="unordered">
    <item>
      <p>The <code>surfaceGrp/@n</code> specifies that this is
      Folio 1 in Volume 2</p>
    </item>
    <item>
      <p>The first <gi>surface</gi> is:</p>
      <list type="unordered">
        <item>
          <p><att>n</att>: The 7th page image (this does
          not mean the 7th page overall, but the 7th digital image)</p>
        </item>
        <item>
          <p><att>type</att>: recto (i.e. the right hand
          page)</p>
        </item>
        <item>
          <p><gi>graphic</gi>: The Islandora PID
          is 4783</p>
        </item>
        <item>
          <p><gi>milestone unit="page" type="Forbes" n="199"/</gi>:
          The number Forbes writes at the top of the page is 199
          (continuous across the volumes)</p>
        </item>
        <item>
          <p><gi>milestone unit="page" type="volume" n="1"</gi>:
          The page number from the beginning of this volume that is
          paginated (i.e. this is the first page in the second volume
          that Forbes put a page number on)</p>
        </item>
        <item>
          <p><gi>milestone unit="page" type="collection" n="199"/</gi>:
          The <hi rendition="simple:italic">idealized</hi> page number.
          This is the page number we use across the project for
          pointers, ids, et cetera. In almost all cases, this is the
          same as the Forbes number; however, in Volume 9, Forbes skips
          from 2099 to 3000, making the last fifty pages of the
          manuscript offset by 991.</p>
        </item>
      </list>
    </item>
  </list>
</div>

<div xml:space="preserve" xml:id="encoding_vol11">
  <head>Encoding the Index Volume (Volume 11)</head>
  <p>As the volume 11 contains the index for the other 10 volumes, the
  encoding for volume 11 is slightly different from a standard TEI
  encoding framework. The folder structure looks like so:</p>
  <list type="unordered">
    <item>
      <p>vol11/</p>
      <list type="unordered">
        <item>
          <p>vol11.xml</p>
        </item>
        <item>
          <p>vol11_vol1.xml</p>
        </item>
        <item>
          <p>vol11_vol2.xml</p>
        </item>
        <item>
          <p>vol11_vol3.xml</p>
        </item>
        <item>
          <p>[...]</p>
        </item>
      </list>
    </item>
  </list>
  <p>The <code>vol11.xml</code> file contains all of the
  metadata for volume 11, but does not contain the transcription for the
  volume. Instead, each volume its own fragment file that contains the
  transcription for that volume's section within the index. This is
  mostly for convience: splitting the files this way makes it easier for
  multiple encoders to work on the index at the same time. Note that
  these fragment files do not begin with the standard
  <gi>TEI</gi> element, but instead use a special
  type of <gi>div</gi>
  (<gi>div</gi>/<att>type</att>="<val>index</val>")
  that contains the transcription for that section of the index. Each
  file will look something like this:</p>
  <egXML xmlns="http://www.tei-c.org/ns/Examples">
<div type="index" xml:id="vol11_vol1"><!--[...]--></div>
</egXML>
  <div xml:id="encoding_vol11_index-and-page-numbers">
    <head>Index and Page Numbers</head>
    <table>
      <row role="label">
        <cell>Volume</cell>
        <cell>Library</cell>
        <cell>Steuart page</cell>
        <cell>NLS folio</cell>
        <cell>Note</cell>
        <cell>Forbes</cell>
        <cell>Paton</cell>
      </row>
      <row>
        <cell><p>Volume 2</p></cell>
        <cell><p>Library 13</p></cell>
        <cell><p>Steuart 3</p></cell>
        <cell><p>NLS 5</p></cell>
        <cell><p>at top of page</p></cell>
        <cell><p>Forbes 199</p></cell>
        <cell><p>Paton 1:113</p></cell>
      </row>
      <row>
        <cell><p>Volume 3</p></cell>
        <cell><p>Library 15</p></cell>
        <cell><p>Steuart 4</p></cell>
        <cell><p>NLS 6</p></cell>
        <cell><p>half way down page</p></cell>
        <cell><p>Forbes 381</p></cell>
        <cell><p>Paton 1:210</p></cell>
      </row>
      <row>
        <cell><p>Volume 4</p></cell>
        <cell><p>Library 23</p></cell>
        <cell><p>Steuart 8</p></cell>
        <cell><p>NLS 10</p></cell>
        <cell><p>halfway down page</p></cell>
        <cell><p>Forbes 625</p></cell>
        <cell><p>Paton 1:344</p></cell>
      </row>
      <row>
        <cell><p>Volume 5</p></cell>
        <cell><p>Library 31</p></cell>
        <cell><p>Steuart 12</p></cell>
        <cell><p>NLS 15</p></cell>
        <cell><p>halfway down page but no note</p></cell>
        <cell><p>Forbes 869</p></cell>
        <cell><p>Paton 2:76</p></cell>
      </row>
      <row>
        <cell><p>Volume 6</p></cell>
        <cell><p>Library 39</p></cell>
        <cell><p>Steuart 16</p></cell>
        <cell><p>NLS 18</p></cell>
        <cell><p>halfway down page but no note</p></cell>
        <cell><p>Forbes 1113</p></cell>
        <cell><p>Paton 2:200</p></cell>
      </row>
      <row>
        <cell><p>Volume 7</p></cell>
        <cell><p>Library 53</p></cell>
        <cell><p>Steuart 23</p></cell>
        <cell><p>NLS 25</p></cell>
        <cell><p>three from the top but no note</p></cell>
        <cell><p>Forbes 1357</p></cell>
        <cell><p>Paton 2:320</p></cell>
      </row>
      <row>
        <cell><p>Volume 8</p></cell>
        <cell><p>Library 67</p></cell>
        <cell><p>Steuart 29</p></cell>
        <cell><p>NLS 32</p></cell>
        <cell><p>three from the top but no note</p></cell>
        <cell><p>Forbes 1599</p></cell>
        <cell><p>Paton 3:65</p></cell>
      </row>
      <row>
        <cell><p>Volume 9</p></cell>
        <cell><p>Library 77</p></cell>
        <cell><p>Steuart 34</p></cell>
        <cell><p>NLS 37</p></cell>
        <cell><p>1/2 way down page but no note</p></cell>
        <cell><p>Forbes 1841</p></cell>
        <cell><p>Paton 3:188</p></cell>
      </row>
      <row>
        <cell><p>Volume 10</p></cell>
        <cell><p>Library 105</p></cell>
        <cell><p>Steuart 48</p></cell>
        <cell><p>NLS 51</p></cell>
        <cell><p>1/2 way down page but no note</p></cell>
        <cell><p>Forbes 3015</p></cell>
        <cell><p>Paton 3:356</p></cell>
      </row>
    </table>
  </div>
  <div xml:id="encoding_vol11_encoding-pages">
    <head>Encoding pages</head>
    <p>Use a self-closing (i.e. empty) <gi>pb</gi>
    element to denote the start of a new physical page in the
    manuscript. In most cases, the <gi>pb</gi>
    element should go exactly where it happens in flow of the text.</p>
    <p>As an example, let's look at these four pages of the introduction
    from volume 11:</p>
    <p><figure>
      <figDesc>Vol 11, page 3</figDesc>
      <graphic url="images/vol11_pg3.jpg"/>
    </figure></p>
    <p><figure>
      <figDesc>Vol 11, page 4</figDesc>
      <graphic url="images/vol11_pg4.jpg"/>
    </figure></p>
    <p>While there are two digitized images, the encoding for the above
    should contain four <gi>pb</gi> elements, one
    for each of:</p>
    <list type="unordered">
      <item>
        <p>the blank verso page</p>
      </item>
      <item>
        <p>the recto page</p>
      </item>
      <item>
        <p>the blank verso page</p>
      </item>
      <item>
        <p>the recto page</p>
      </item>
    </list>
    <p>Since the first paragraph of text extends across the page
    boundary, we place the <gi>pb</gi> within the
    middle of the paragraph:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<pb facs="lib:3"/> <pb facs="lib:3"/> <div type="preface"><lb/><opener><salute>Dear <persName>Mr. Blank</persName>,</salute></opener><lb/><p>I have at rescued
                  <lb/> the <title level="m">Index to the Lion in Mourning</title> from
                  <lb/>my father's hands where it has lain
                  <lb/><!--[....]--><lb/>Chambers thirteen years ago. You may
                  <pb facs="lib:4"/><pb facs="lib:4"/><fw type="pageNum" place="right">2</fw><lb/>therefore submit the matter to the 
                  <lb/>Curators whenever you choose.</p></div>
</egXML>
    <p>There are a few things to note here:</p>
    <list type="unordered">
      <item>
        <p>Each line of text is denoted by using the
        <gi>lb</gi> (line beginning) element. Like
        the <gi>pb</gi> element, the
        <gi>lb</gi> element is self-closing and
        denotes the beginning of a line.</p>
      </item>
      <item>
        <p>Each <gi>pb</gi> element also has a
        <att>facs</att> attribute that denotes the SFU
        Library page number by using the special
        <val>lib:</val> prefix. The
        <att>facs</att> attribute, in other words, provides
        a mechanism for aligning the transcription with the digital
        images housed at SFU library.</p>
      </item>
      <item>
        <p>We encode the written page number using the
        <gi>fw</gi> (formework) element with an
        <att>type</att> value of
        <val>pageNum</val> and an
        <att>place</att> value of
        <val>right</val>.</p>
      </item>
    </list>
  </div>
  <div xml:id="encoding_vol11_encoding-the-indexes">
    <head>Encoding the Indexes</head>
    <p>Each indexed volume has a separate file that will house your
    transcription. These are a bit strange compared to the rest of the
    documents; they begin with a <gi>div</gi>
    element, rather than a <gi>TEI</gi> (this is
    because these aren't distinct documents, but rather fragments all
    contained with one document).</p>
    <p>Each volume's index can be considered as a single
    <gi>list</gi> with each letter, narrative, etc
    found in the manuscript as a separate
    <gi>item</gi> in that list:</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<div type="index" xml:id="vol11_vol1"><pb facs="lib:9"/><fw type="pageNum" place="left">1</fw><fw type="pageNum" place="right">3</fw><list><item><!--The first item--></item><item><!--The second item--></item><!--....--></list></div>
</egXML>
    <p>Like above, these documents should contain all of the
    bibliographic information for the document (i.e. page beginnings
    [<gi>pb</gi>], page numbers and other
    formeworks [<gi>fw</gi>], etc).</p>
    <div xml:id="encoding_vol11_index-items">
      <head>Index Items</head>
      <div xml:id="encoding_vol11_basic-structure">
        <head>Basic Structure</head>
        <p>Within the <gi>list</gi>, encode each
        item as a separate <gi>item</gi> that
        contains the title of the piece and a page number, encoded using
        the <gi>title</gi> and
        <gi>num</gi> tag, respectively:</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
<list><lb/><item><!--Encoding of the title simplified for demonstrative purposes...--><title>Letter from the Revt. Mr. Lyon to his mother + Sisters</title><num>1</num></item></list>
</egXML>
        <p>Note that we do not encode information about the separating
        line between the page number and the title.</p>
      </div>
      <div xml:id="encoding_vol11_line-beginnings">
        <head>Line Beginnings</head>
        <p>All line beginnings must be encoded using the
        <gi>lb</gi> element; always include the
        <gi>lb</gi> precisely where the line
        begins. (Note that there is no equivalent line ending tag.)</p>
        <p>Since XML collapses all whitespace to a single space, it is
        not imperative that the line beginning is preceded or followed
        by a carriage return or a space. For consistency's sake,
        however, the project recommends placing a hard return before the
        line beginning tag and placing no spaces after the
        <gi>lb</gi>:</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
<!--Note that the lb goes before the block element--> <lb/> <p>Here is a 
                  <lb/>the second line and then the
                  <lb/>third line.</p>
</egXML>
        <p>Line beginnings preceded by a piece of punctuation to denote
        end-of-line hyphens (or, in the case of Steuart, colons) require
        a bit of special tagging:</p>
        <list type="unordered">
          <item>
            <p>Encode the punctuation using the
            <gi>pc</gi> element with a
            <att>force</att>=<val>weak</val></p>
          </item>
          <item>
            <p>Do not put any spaces before or after the
            <gi>lb</gi></p>
          </item>
        </list>
        <p>For example:</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
<title>Copy of a Letter from <persName ref="prs:16"><choice><abbr>Captn.</abbr><expan>Captain</expan></choice> Malcolm Mac<pc force="weak">;</pc><lb/>Leod</persName></title>
</egXML>
      </div>
      <div xml:id="encoding_vol11_marginalia-in-index-items">
        <head>Marginalia in Index Items</head>
        <p>Some of the index items will have marginal marks or
        annotations associated with that item that we want to capture.
        To do so, encode the note text using
        <gi>note</gi> element with an
        <att>place</att> to signal the note's position. The
        <gi>note</gi> element should be contained
        within the <gi>item</gi> with which it is
        associated. For example:</p>
        <p><figure>
          <figDesc>From vol11; item with note</figDesc>
          <graphic url="images/item_with_note.png"/>
        </figure></p>
        <p>This item from volume 11 is encoded like so:</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
<item><note place="left">v</note><title>Speech of Mr. Theodore Deacon</title><num>37</num></item>
</egXML>
      </div>
    </div>
  </div>
</div>

<div xml:space="preserve" xml:id="writing_documentation">
  <head>Writing Documentation</head>
  <div xml:id="writing_documentation_why-write-documentation">
    <head>Why write documentation?</head>
    <p/>
  </div>
  <div xml:id="writing_documentation_forking-the-repository">
    <head>Forking the Repository</head>
    <p/>
  </div>
  <div xml:id="writing_documentation_working-on-the-documentation">
    <head>Working on the documentation</head>
    <div xml:id="writing_documentation_editing-existing-documents">
      <head>Editing existing documents</head>
      <p/>
    </div>
    <div xml:id="writing_documentation_adding-new-documents">
      <head>Adding new documents</head>
      <p/>
    </div>
    <div xml:id="writing_documentation_re-arranging-documents">
      <head>Re-arranging documents</head>
      <p/>
    </div>
  </div>
</div>

         
      </body>
      <back>
         <div>
            <head>Appendix</head>
            <schemaSpec ident="lim" start="TEI div person place org biblStruct" source="tei:4.7.0">

               <moduleRef key="analysis" include="pc w"/><elementSpec ident="pc" mode="change" module="analysis">
            <!--Remove all other attributes-->
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.segLike" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <content>
                     <textNode/>
                  </content>
                  <constraintSpec ident="pc.onlyPunct" scheme="schematron" mode="add">
                     <desc>Only punctuation in pc.</desc>
                     <constraint>
                        <sch:rule context="tei:pc">
                           <sch:assert test="matches(text(),'^[\p{P}=]$')">ERROR: Only a single punctuation character is allowed in pc</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="dash.shouldBeInWord" scheme="schematron" mode="add">
                     <desc>Only punctuation in pc.</desc>
                     <constraint>
                        <sch:rule context="tei:pc[text() = '-'][@force='weak'][ancestor::tei:TEI/descendant::tei:revisionDesc/@docStatus='inProgress']">
                           <sch:assert test="ancestor::tei:w">ERROR: All end of line hyphens must be contained by the word (&lt;w&gt;) element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="unit" mode="delete"/>
                     <attDef ident="pre" mode="delete"/>
                     <attDef ident="force" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="w" mode="change" module="analysis">
                  <classes mode="change">
                     <memberOf key="att.segLike" mode="delete"/>
                     <memberOf key="att.fragmentable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <constraintSpec ident="w.shouldContainPC" scheme="schematron" mode="add">
                     <desc>Words should always contain a pc</desc>
                     <constraint>
                        <sch:rule context="tei:w[not(@part)]">
                           <sch:assert test="descendant::tei:pc[@force='weak'] and descendant::tei:lb">ERROR: Word elements must include a pc and an lb,
                              since the element should only be used to flag words separated across line boundaries </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="w.shouldBeInParts" scheme="schematron" mode="add">
                     <desc>Words should always contain a pc</desc>
                     <constraint>
                        <sch:rule context="tei:w">
                           <sch:assert test="not(descendant::tei:fw or descendant::tei:pb)">ERROR: Do not include formeworks or page beginnings in a word element; if a word is split across pages, then use the @part attribute to signal the initial and final parts of the word. </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="w.partsShouldMatch" scheme="schematron" mode="add">
                     <desc>Words should always contain a pc</desc>
                     <constraint>
                        <sch:rule context="tei:w">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert test="not(matches($text,'^\s|\s$'))">ERROR: <sch:name/> should begin or end with spaces.</sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:text[descendant::tei:w[@part]]">
                           <sch:assert test="count(descendant::tei:w[@part]) mod 2 = 0">ERROR: Odd number of split words found in this transcription.</sch:assert>
                           
                        </sch:rule>
                        <sch:rule context="tei:w[@part = 'F']">

                           <sch:assert test="preceding-sibling::tei:w[1][@part = 'I']">ERROR: Initial word part missing following final part.</sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:w[@part = 'I']">
                           
                           <sch:assert test="following-sibling::tei:w[1][@part = 'F']">ERROR: Final word part missing preceding initial part. </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><classSpec ident="att.linguistic" module="analysis" type="atts" mode="delete"/>
               <moduleRef key="core" include="abbr add author bibl biblStruct choice cit corr date del desc divGen editor ellipsis emph expan foreign gap gloss graphic head hi imprint item l label lb lg list listBibl mentioned milestone name note noteGrp num orig p pb ptr pubPlace publisher q quote ref reg resp respStmt rs sic term time title unclear"/><elementSpec ident="abbr" module="core" mode="change">
                  <classes mode="change">
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <constraintSpec ident="abbr.shouldntContainJustAmp" scheme="schematron" mode="add">
                     <desc>Don't expand the ampersand only.</desc>
                     <constraint>
                        <sch:rule context="tei:abbr">
                           <sch:let name="content" value="string(.)"/>
                           <sch:assert test="not(matches($content, '^\s*&amp;\s*$'))">ERROR: There is no need to tag ampersands when it means "and".</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="abbr.typeCheck" scheme="schematron" mode="add">
                     <desc>Type is required when not in choice</desc>
                     <constraint>
                        <sch:pattern>
                           <!--TODO: Remove @ref once feasible-->
                           <sch:rule context="tei:choice/tei:abbr">
                              <sch:assert test="not(@type)">ERROR: Do not put a type attribute on abbrs in choice.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:abbr[not(parent::tei:choice)]">
                              <sch:assert test="@type">ERROR: @type is required when abbr is not in a choice.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef mode="change" ident="type">
                        <valList mode="replace" type="closed">
                           <valItem ident="another" mode="add">
                              <desc>anoyr</desc>
                              <gloss>Abbreviation for <mentioned>another</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="Brother" mode="add">
                              <desc>Broyr</desc>
                              <gloss>Abbreviation for <mentioned>Brother</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="which" mode="add">
                              <desc>qch</desc>
                              <gloss>Abbreviation for <mentioned>which</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="whom" mode="add">
                              <desc>qm</desc>
                              <gloss>Abbreviation for <mentioned>whom</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="when" mode="add">
                              <desc>qn</desc>
                              <gloss>Abbreviation for <mentioned>when</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="who" mode="add">
                              <desc>qo</desc>
                              <gloss>Abbreviation for <mentioned>who</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="what" mode="add">
                              <desc>qt</desc>
                              <gloss>Abbreviation for <mentioned>what</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="with" mode="add">
                              <desc>wt</desc>
                              <gloss>Abbreviation for <mentioned>with</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="the" mode="add">
                              <desc>ye</desc>
                              <gloss>Abbreviation for <mentioned>the</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="then" mode="add">
                              <desc>yn</desc>
                              <gloss>Abbreviation for <mentioned>then</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="your" mode="add">
                              <desc>yr</desc>
                              <gloss>Abbreviation for <mentioned>your</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="that" mode="add">
                              <desc>yt</desc>
                              <gloss>Abbreviation for <mentioned>that</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="them" mode="add">
                              <desc>ym</desc>
                              <gloss>Abbreviation for <mentioned>them</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="there" mode="add">
                              <desc>yre</desc>
                              <gloss>Abbreviation for <mentioned>there</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="this" mode="add">
                              <desc>ys</desc>
                              <gloss>Abbreviation for <mentioned>this</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="fm" mode="add">
                              <desc>fm</desc>
                              <gloss>Abbreviation for <mentioned>from</mentioned></gloss>
                           </valItem>
                           <valItem ident="qre" mode="add">
                              <desc>qre</desc>
                              <gloss>Abbreviation for <mentioned>where</mentioned></gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="add" module="core" mode="change">
                  <classes mode="change">
                     <!--We've deleted att.editLike, so 
                        we must add att.written -->
                     <memberOf key="att.written" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="bibl" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.docStatus" mode="delete"/>
                  </classes>
               </elementSpec><elementSpec ident="corr" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.transcriptional, since it should only be in <choice>-->
                     <memberOf key="model.pPart.transcriptional" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="date" module="core" mode="change">
                  <classes mode="replace">
                     <memberOf key="model.dateLike" mode="add"/>
                     <memberOf key="model.publicationStmtPart.detail"/>
                     <memberOf key="att.datable.w3c" mode="add"/>
                     <memberOf key="att.global.rendition" mode="add"/>
                     <memberOf key="lim.att.global.fragmentable" mode="add"/>
                  </classes>
                  
               </elementSpec><elementSpec ident="del" module="core" mode="change">
                  <classes mode="change">
                     <!--We've deleted att.editLike, so 
                        we must add att.written -->
                     <memberOf key="att.written" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="ellipsis" module="core" mode="change">
                  <exemplum>
                     <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        He said, in the Event of a R<ellipsis>
                           <metamark><space/></metamark>
                           <supplied resp="team:JT1">estoration</supplied>
                        </ellipsis>,
                     </egXML>
                  </exemplum>
                  <exemplum>
                     <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        If The P<ellipsis>
                           <metamark><space/></metamark>
                           <choice>
                              <seg>rince</seg>
                              <seg>retender</seg>
                           </choice>
                        </ellipsis> returns...
                     </egXML>
                  </exemplum>
                  
               </elementSpec><elementSpec ident="expan" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.editorial, since it should only be in <choice>-->
                     <memberOf key="model.pPart.editorial" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="head" module="core" mode="change">
                  <constraintSpec scheme="schematron" ident="head.bdHidden">
                     <constraint>
                        <sch:rule context="tei:head[matches(@rendition,'rnd:hidden')]">
                           <sch:assert test="$isBornDigital">ERROR: Only use rnd:hidden in born digital documents.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="rendition" mode="change">
                        <valList type="closed" mode="change">
                           <valItem mode="add" ident="rnd:hidden">
                              <gloss>hidden</gloss>
                              <desc>A heading that is
                                 hidden (for accessibility purposes).</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="item" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.analytic" mode="add"/>
                  </classes>
                  <constraintSpec ident="item.indexItemsMustHaveTitleAndNum" scheme="schematron" mode="add">
                     <desc>All index items must contain a title and a number</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:div[@type='index']/tei:list/tei:item">
                              <sch:assert test="count(tei:num) gt 0">ERROR: All index items must contain at least one num element.</sch:assert>
                              <sch:assert test="count(descendant::tei:title) gt 0">ERROR: All index items must contain at least one title element.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="l" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.analytic" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="lb" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.facs" mode="add"/>
                     <memberOf key="att.spanning" mode="delete"/>
                  </classes>
                  <!--                  <constraintSpec ident="lb.noSpaces" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:lb[preceding-sibling::node()[1][self::tei:pc]]">
                           <sch:assert test="matches(following::text()[1],'^\S')">ERROR: All punctuation separated words in lines should not have any spaces after the line beginning element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>-->
                  <constraintSpec ident="lb.shouldUseDecimal" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:lb[@facs]">
                           <sch:assert test="matches(@facs,'(lib|pg):\d+\.\d+')">ERROR: lb elements with facs must specify the line in the form lib:#.lineNum or pg:#.lineNum (e.g. lib:23.2)</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="list" module="core" mode="change">
                  <constraintSpec scheme="schematron" ident="list.bornDigitalNeedsRendition">
                     <constraint>
                        <sch:rule context="tei:list[not(@rendition)]">
                           <sch:assert test="not($isBornDigital)">ERROR: All lists in born digital document require the rendition attribute.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="rendition" mode="change">
                        <valList type="closed" mode="change">
                           <valItem mode="add" ident="rnd:list_ordered">
                              <desc>An ordered list</desc>
                           </valItem>
                           <valItem mode="add" ident="rnd:list_unordered">
                              <desc>An unordered list</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="milestone" module="core" mode="change">
                  <constraintSpec ident="milestone.sectionInBody" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:milestone[@unit='section']">
                              <sch:assert test="ancestor::tei:body">ERROR: Section milestones should be within the body of the text</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="milestone.itemInText" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:milestone[@unit='item']">
                              <sch:assert test="ancestor::tei:text and preceding-sibling::tei:body">ERROR: Item milestones should only occur at the end of the item after the closing body tag.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="unit" mode="change">
                        <valList type="semi" mode="replace">
                           <valItem ident="section" mode="add">
                              <gloss>section</gloss>
                              <desc>A horizontal rule representing a shift in section</desc>
                           </valItem>
                           <valItem ident="item" mode="add">
                              <gloss>item</gloss>
                              <desc>A horizontal rule representing the end of an item</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="name" module="core" mode="change">
                  <constraintSpec ident="name.notForPeopleOrPlaces" mode="change" scheme="schematron">
                     <desc>Name should only be used if there isn't a more specific element.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:name[@ref]">
                           <sch:assert test="not(matches(@ref,'^prs:'))">ERROR: Use &lt;persName&gt; to tag names of people.</sch:assert>
                           <sch:assert test="not(matches(@ref,'^plc:'))">ERROR: Use &lt;placeName&gt; to tag names of places.</sch:assert>
                           <sch:assert test="not(matches(@ref,'^org:'))">ERROR: Use &lt;orgName&gt; to tag names of organizations.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="opt">
                        <valList type="closed" mode="add">
                           <valItem ident="event" mode="add">
                              <gloss>event</gloss>
                              <desc>The name of an event (e.g. "The Battle of Prestonpans")</desc>
                           </valItem>
                           <valItem ident="object" mode="add">
                              <gloss>object</gloss>
                              <desc>The name of an object (e.g. "Excalibur")</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="note" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <content>
                     <alternate>
                        <sequence>
                           <sequence preserveOrder="false">
                              <elementRef key="supplied" minOccurs="0" maxOccurs="unbounded"/>
                              <elementRef key="noteMarker" minOccurs="0" maxOccurs="unbounded"/>
                           </sequence>
                           <alternate>
                              <sequence>
                                 <elementRef key="p" minOccurs="1" maxOccurs="unbounded"/>
                                 <elementRef key="closer" minOccurs="0"/>
                              </sequence>
                              <elementRef key="NB" minOccurs="1" maxOccurs="1"/>
                           </alternate>
                        </sequence>
                        <macroRef key="macro.specialPara"/>
                     </alternate>
                  </content>
                  <constraintSpec ident="note.mustHaveTypeInText" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[ancestor::tei:text][not(ancestor::tei:div[@type='footnotes'])]">
                              <sch:assert test="@type">ERROR: All notes in transcriptions must have a @type.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="note.coOccurenceConstraints" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@type='editorial']">
                              <sch:assert test="@resp">ERROR: All editorial notes must have a @resp</sch:assert>
                              <sch:assert test="not(@anchored)">ERROR: Do not use @anchored for editorial notes</sch:assert>
                              <sch:assert test="not(@hand)">ERROR: Do not use @hand for editorial notes.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:note[@type='lim']">
                              <sch:assert test="not(@resp)">ERROR: Do not use @resp on LiM notes. Use @hand instead.</sch:assert>
                              <sch:assert test="every $text in text() satisfies not(matches($text,'\S'))">ERROR: All lim notes
                              must have structured context (i.e. 0 or more noteMarkers, either a sequence of paragraphs and a closer OR an NB) </sch:assert>
                              <sch:assert test="@anchored">ERROR: All LiM notes must specify whether it is anchored using the @anchored attribute.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:note[@type='lim']/tei:supplied">
                              <sch:assert test="tei:noteMarker">ERROR: Supplied as a direct child of note must contain a noteMarkers.</sch:assert>
                              <sch:assert test="empty(tei:*[not(self::tei:noteMarker)])">ERROR: Only noteMarkers are allowed within note[@type='lim']/supplied.</sch:assert>
                              <sch:assert test="every $text in text() satisfies not(matches($text,'\S'))">ERROR: Do not put text within the supplied in a noteMarker.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="note.unknownsShouldBeFixed" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@type = 'unknown']">
                              <sch:assert test="//tei:revisionDesc[@docStatus=('empty','uneditedTranscription')]">WARNING: Unknown notes should be replaced by either
                                 the appropriate encoding (usually supplied, gap, del, etc) or should become a @type='editorial'.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="anchoredNotesShouldUseNoteMarker" scheme="schematron">
                     <desc>Anchored notes should have a child noteMarker</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@anchored='true']">
                              <sch:assert test="tei:noteMarker or tei:supplied/tei:noteMarker">ERROR: Anchored notes must
                                 contain a noteMarker element that points to the id of the
                                 note marker in the body of the text.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:note[@anchored='false']">
                              <sch:assert test="@place">ERROR: Unanchored notes must have a @place value
                                 specifying where it is on the page.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" usage="rec" mode="change">
                        <valList type="semi" mode="add">
                           <valItem ident="editorial" mode="add">
                              <gloss>editorial note</gloss>
                              <desc>An editorial note written by a team member.</desc>
                           </valItem>
                           <valItem ident="lim" mode="add">
                              <gloss>Forbes note</gloss>
                              <desc>A note that appears in the manuscript (left by Forbes or someone else).</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
                  
                  <!--<attList>
                     <!-\-Now we need the note have a choice of attributes:
                     If there's a type and its one of the three special types that
                     require attributes, then do that-\->
                     <attList org="choice">
                        <!-\-If it's a type not listed below,
                        then it shouldn't have any other attributes-\->
                        <attList org="group">
                           <attDef ident="type" usage="opt">
                              <datatype>
                                 <dataRef key="teidata.enumerated"/>
                              </datatype>
                           </attDef>
                        </attList>
                        <!-\-Group 2: An editorial note,
                        which must include @resp-\->
                        <attList org="group">
                           <attDef ident="type" usage="req">
                              <valList type="closed">
                                
                              </valList>
                           </attDef>
                           <!-\-Since we use notes in the teiHeader,
                              we have to make the use of resp required via schematron-\->
                           <attDef ident="resp" usage="req">
                              <gloss versionDate="2009-11-02" xml:lang="en">responsible party</gloss>
                              <datatype maxOccurs="unbounded">
                                 <dataRef key="teidata.pointer"/>
                              </datatype>
                              <constraintSpec ident="note.editorial.requiresResp" scheme="schematron">
                                 <constraint>
                                    <sch:rule context="tei:note[@type='editorial'][not(root(.)/*[matches(@xml:id,'vol11')])]">
                                       <sch:assert test="@resp">ERROR: All editorial notes must point to a team member.</sch:assert>
                                    </sch:rule>
                                 </constraint>
                              </constraintSpec>
                              <remarks>
                                 <p>All editorial notes must include a resp in order to identify
                                    the encoder responsible.</p>
                              </remarks>
                           </attDef>
                        </attList>
                        <!-\-Group 3: A LiM Note,
                        which is a primary source note-\->
                        <attList org="group">
                           <attDef ident="type" usage="req">
                              <valList type="closed">
                                
                              </valList>
                           </attDef>
                           <!-\-Optional hand attribute on lim notes-\->
                           <attDef ident="hand" usage="opt">
                              <desc>points to a <gi>handNote</gi> element describing the hand considered responsible for the
                                 content of the element concerned.</desc>
                              <datatype>
                                 <dataRef key="teidata.pointer"/>
                              </datatype>
                           </attDef>
                           <!-\-Sub-group:
                              if anchored is true, then it needs an @n-\->
                           <attList org="choice">
                              <attList org="group">
                                 <attDef ident="anchored" usage="req">
                                    <gloss>anchored</gloss>
                                    <desc>indicates whether the copy text shows the exact place of reference for the note.</desc>
                                    <valList type="closed">
                                       <valItem ident="true">
                                          <gloss>true</gloss>
                                          <desc>The note is anchored (i.e. it contains a symbol that anchors it in place)</desc>
                                       </valItem>
                                    </valList>
                                 </attDef>
                              </attList>
                              <attList org="group">
                                 <attDef ident="anchored" usage="req">
                                    <gloss>anchored</gloss>
                                    <desc>indicates whether the copy text shows the exact place of reference for the note.</desc>
                                    <valList type="closed">
                                       <valItem ident="false">
                                          <gloss>false</gloss>
                                          <desc>The note is not anchored (i.e. it does not contain a symbol that anchors it in place)</desc>
                                       </valItem>
                                    </valList>
                                 </attDef>
                                 <attDef ident="place" usage="req">
                                    <desc versionDate="2012-10-07" xml:lang="en">specifies where this item is placed.</desc>
                                    <datatype>
                                       <dataRef key="limdata.placement"/>
                                    </datatype>
                                    <constraintSpec ident="note.lim.requiresPlace" scheme="schematron">
                                       <constraint>
                                          <sch:rule context="tei:note[@type='lim']">
                                             <sch:assert test="@place">ERROR: All lim notes require a @place attribute to describe
                                                where on the page the original note is placed.</sch:assert>
                                          </sch:rule>
                                       </constraint>
                                    </constraintSpec>
                                 </attDef>
                              </attList>
                           </attList>
                        </attList>
                     </attList>
                  </attList>-->
               </elementSpec><elementSpec ident="noteGrp" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="lim.att.boolean" mode="add"/>
                  </classes>
                  <content>
                     <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="p" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.analytic" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="pb" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                     <memberOf key="att.global.facs" mode="add"/>
                  </classes>
                  <constraintSpec ident="pb.noDecimal" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:pb[@facs]">
                           <sch:assert test="matches(@facs,'^(lib|pg):\d+$')">ERROR: pb/@facs should be either the Forbes page number (i.e. pg:233 for the page Forbes numbers as 233) or via the page number in the library catalogue using the lib scheme (i.e. lib:22).</sch:assert>
                        </sch:rule>
                        
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="pb.unique" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:pb[@facs][not(ancestor::tei:TEI[@xml:id = 'vol11'])]">
                           <sch:let name="facsPtr" value="@facs"/>
                           <sch:let name="allFacs" value="//tei:pb[@facs]"/>
                           <sch:assert test="count($allFacs[contains-token(@facs, $facsPtr)]) = 1">
                              ERROR: Duplicate page beginning: <sch:value-of select="$facsPtr"/>
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                <!--Make @facs required-->
                     <attDef ident="facs" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="q" module="core" mode="replace">
                  <gloss versionDate="2012-03-26" xml:lang="en">quoted</gloss>
                  <desc versionDate="2012-03-26" xml:lang="en">contains material which is distinguished from the
                     surrounding text using quotation marks or a similar method, for any one of a variety of reasons including, but not limited to: direct
                     speech or thought, technical terms or jargon, authorial distance, quotations from elsewhere, and
                     passages that are mentioned but not used.</desc>
                  <classes>
                     <memberOf key="model.hiLike"/>
                     <memberOf key="model.common"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
                  <!--               <constraintSpec ident="allQuotationMarksShouldBeInQ" scheme="schematron">
                        <desc>Quotation marks must be in q elements.</desc>
                        <constraint>
                           <sch:rule context="tei:*[ancestor::tei:text]
                              [ancestor::tei:TEI/descendant::tei:limItem]
                              [ancestor::tei:TEI/descendant::tei:revisionDesc/@docStatus='inProgress']
                              [not(ancestor-or-self::tei:q)]
                              [some $text in text() satisfies matches($text,'\S')]">
                              <sch:let name="marksRex" value="'[' || codepoints-to-string(34) || '“”]'"/>
                              <sch:let name="string" value="string-join(text(),'')"/>
                              <sch:assert test="not(matches($string, $marksRex))">ERROR: All quotation marks must be contained at some point by a q element.</sch:assert>
                           </sch:rule>
                        </constraint>
                  </constraintSpec>-->
                  <attList org="choice">
                     <attList org="group">
                        <attDef ident="type" usage="opt" mode="replace">
                           <datatype minOccurs="1" maxOccurs="1">
                              <dataRef key="teidata.enumerated"/>
                           </datatype>
                           <valList type="closed">
                              <valItem ident="speech">
                                 <gloss>speech</gloss>
                                 <desc>Representation of speech</desc>
                              </valItem>
                           </valList>
                        </attDef>
                        <attDef ident="who" mode="add" usage="opt">
                           <desc versionDate="2005-11-05" xml:lang="en">indicates the person, or group of people, to whom the element content is ascribed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="toWhom" mode="add" usage="opt">
                           <desc versionDate="2018-07-19" xml:lang="en">indicates the person, or group of people, to whom a speech act or action is directed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                     </attList>
                     <attList org="group">
                        <attDef ident="type" usage="opt" mode="replace">
                           <datatype minOccurs="0" maxOccurs="1">
                              <dataRef key="teidata.enumerated"/>
                           </datatype>
                           <valList type="closed" mode="replace">
                              <valItem ident="letter" mode="add">
                                 <gloss>letter</gloss>
                                 <desc>Representation of writing (i.e. a letter)</desc>
                              </valItem>
                           </valList>
                        </attDef>
                        <attDef ident="who" mode="add" usage="opt">
                           <desc versionDate="2005-11-05" xml:lang="en">indicates the person, or group of people, to whom the element content is ascribed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="toWhom" mode="add" usage="opt">
                           <desc versionDate="2018-07-19" xml:lang="en">indicates the person, or group of people, to whom a speech act or action is directed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="where" mode="add" usage="opt">
                           <desc versionDate="2007-06-11" xml:lang="en">indicates the location of an event by pointing to a <gi>place</gi> element</desc>
                           <datatype>
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="toWhere" mode="add" usage="opt">
                           <desc>indicates the location of something being sent.</desc>
                           <datatype>
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                     </attList>
                     <attList org="group">
                        <attDef ident="type" usage="opt" mode="replace">
                           <datatype minOccurs="0" maxOccurs="1">
                              <dataRef key="teidata.enumerated"/>
                           </datatype>
                           <valList type="closed" mode="replace">
                              <valItem ident="quotation" mode="add">
                                 <gloss>quotation</gloss>
                                 <desc>Represents some sort of other quotation</desc>
                              </valItem>
                           </valList>
                        </attDef>
                     </attList>
                  </attList>
               </elementSpec><elementSpec ident="quote" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.citing"/>
                  </classes>
               </elementSpec><elementSpec ident="rs" module="core" mode="change">
                  <constraintSpec ident="rs.familyNoRef" mode="change" scheme="schematron">
                     <desc>Family references should not have a ref.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:rs[@type='family']">
                           <sch:assert test="not(@ref)">ERROR: Do not use a @ref attribute on for a family reference since it can't point to anything.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList mode="change">
                           <valItem mode="add" ident="person">
                              <gloss>person</gloss>
                              <desc>An indirect reference to a person (e.g. "his father"); use &lt;persName&gt; for direct references (i.e. "John Smith").</desc>
                           </valItem>
                           <valItem mode="add" ident="event">
                              <gloss>event</gloss>
                              <desc>An indirect reference to an event (e.g. "the day"); use &lt;name type="event"&gt; for direct references to events.</desc>
                           </valItem>
                           <valItem mode="add" ident="place">
                              <gloss>place</gloss>
                              <desc>An indirect reference to a place (e.g. "over there"); use &lt;placeName&gt; for direct references to places (i.e. "Edinburgh").</desc>
                           </valItem>
                           <valItem mode="add" ident="object">
                              <gloss>object</gloss>
                              <desc>An indirect reference to an object (e.g. "that thing"); use &lt;name type="object"&gt; for direct references to objects (i.e. "Excalibur").</desc>
                           </valItem>
                           <valItem mode="add" ident="family">
                              <gloss>family</gloss>
                              <desc>An reference to a family (e.g. "To my family").</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="sic" module="core" mode="change">
                  <classes mode="change">
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="time" module="core" mode="change">
                  <classes mode="replace">
                      <memberOf key="att.global.rendition" mode="add"/>
                      <memberOf key="att.datable.w3c" mode="add"/>
                      <memberOf key="att.duration.w3c" mode="add"/>
                      <memberOf key="model.dateLike" mode="add"/>
                  </classes>
                  <constraintSpec ident="time.shouldHaveTextInText" scheme="schematron">
                     <desc>The <gi>time</gi> element should contain text</desc>
                     <constraint>
                        <sch:rule context="tei:time[ancestor::tei:text]">
                           <sch:assert test="normalize-space(string-join(descendant::text(),'')) ne ''">
                              ERROR: The time element should not be empty.
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               <moduleRef key="corpus" include="activity creation setting settingDesc"/><elementSpec ident="setting" module="corpus" mode="change">
                  <constraintSpec ident="scaffold.mustHaveTrialPlace" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:setting[ancestor::tei:limItem[matches(@type,'speech')]]">
                              <sch:assert test="tei:scaffold">ERROR: All speeches must have a scaffold element.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="settingDesc" module="corpus" mode="change">
                  <content>
                     <sequence>
                        <elementRef key="setting" minOccurs="1" maxOccurs="unbounded"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                     
                  </content>
               </elementSpec>
               <moduleRef key="header" include="abstract catDesc catRef category change correspAction correspContext correspDesc creation encodingDesc extent fileDesc handNote idno langUsage language listChange listPrefixDef notesStmt prefixDef profileDesc projectDesc publicationStmt rendition revisionDesc sourceDesc tagsDecl taxonomy teiHeader textClass titleStmt"/><elementSpec ident="change" mode="change" module="header">
                  <constraintSpec ident="changeMustPointToTeam" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:change">
                              <sch:assert test="every $ptr in tokenize(@who,'\s+') satisfies matches($ptr,'^team:')">
                                 ERROR: Every pointer in change/@who must start with 'team:'.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="changeMustHaveContent" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:change">
                              <sch:assert test="not(normalize-space(string-join(descendant::text(),'')) = '')">
                                 ERROR: change elements must contain meaningful content.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="who" mode="change" usage="req"/>
                     <attDef ident="when" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="correspAction" module="header" mode="change">
                  <classes mode="change">
                     <memberOf key="att.datable" mode="add"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.ascribed" mode="add"/>
                  </classes>
                  <content>
                     <!--Allow for empty content-->
                     <alternate>
                        <classRef key="model.correspActionPart" minOccurs="0" maxOccurs="unbounded"/>
                        <classRef key="model.pLike" minOccurs="0" maxOccurs="unbounded"/>
                     </alternate>
                  </content>
               </elementSpec><elementSpec ident="creation" module="header" mode="change">
                  <content>
                     <sequence>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="date" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                  </content>
                  <constraintSpec ident="onlyUseCreationForAccountsNarratives" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:creation">
                              <sch:assert test="ancestor::tei:profileDesc/tei:limItem[@type=                                  ('accountNarrative','conversation','misc', 'speech')]">ERROR: The creation element should only be used for account/narratives, conversations, and speeches, since the date/place of the transcription may differ from the setting.</sch:assert>
                              <sch:assert test="count(tei:*) gt 0">ERROR: The creation element requires at least one of placeName, date, or note.</sch:assert>
                           </sch:rule>
                           
                        </sch:pattern>
                        
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="handNote" module="header" mode="change">
                  <attList>
                     <attDef ident="xml:id" mode="change" usage="req"/>
                     <attDef ident="medium" mode="change" usage="rec">
                        <valList type="closed" mode="add">
                           <valItem ident="pencil" mode="add"/>
                           <valItem ident="ink" mode="add"/>
                           <valItem ident="crayon" mode="add"/>
                        </valList>
                     </attDef>
                     <attDef ident="n" mode="delete"/>
                     <attDef ident="scribe" mode="delete"/>
                     <attDef ident="script" mode="delete"/>
                     <attDef ident="scriptRef" mode="delete"/>
                     <attDef ident="part" mode="delete"/>
                     <attDef ident="scope" mode="delete"/>
                     <attDef ident="source" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="langUsage" module="header" mode="change">
                  <content>
                     <elementRef key="language" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="profileDesc" module="header" mode="change">
                  <content>
                     <alternate>
                        <sequence>
                           <alternate>
                              <sequence>
                                 <elementRef key="locusGrp"/>
                                 <elementRef key="locus" minOccurs="0" maxOccurs="1"/>
                              </sequence>
                              <elementRef key="locus" minOccurs="1" maxOccurs="2"/>
                           </alternate>
                           <elementRef key="abstract" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="langUsage" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="limItem"/>
                           <elementRef key="handNotes" minOccurs="0" maxOccurs="1"/>
                        </sequence>
                        <elementRef key="catRef"/>
                     </alternate>
                  </content>
               </elementSpec><elementSpec ident="revisionDesc" mode="change" module="header">
                  <content>
                     <elementRef key="change" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
                  <constraintSpec ident="revisionDescStatusMustMatch" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc">
                              <sch:let name="firstChangeWithDocStatus" value="tei:change[@docStatus][1]"/>
                              <sch:let name="firstChangeWithMetaStatus" value="tei:change[@metaStatus][1]"/>
                              <sch:let name="docStatus" value="@docStatus"/>
                              <sch:let name="metaStatus" value="@metaStatus"/>
                              <sch:assert test="exists($firstChangeWithDocStatus) = exists($metaStatus)">
                                 ERROR: If @docStatus appears on a change element or on a revisionDesc, then both the revisionDesc element and at least one change element must feature @docStatus.  
                              </sch:assert>
                              <sch:assert test="exists($firstChangeWithMetaStatus) = exists($metaStatus)">
                                 ERROR: If @metaStatus appears on a change element or on a revisionDesc, then both the revisionDesc element and at least one change element must feature @metaStatus.  
                              </sch:assert>
                              <sch:assert test="exists($docStatus) or exists($metaStatus)">
                                 ERROR: At least one of @docStatus or @metaStatus must be present.
                              </sch:assert>
                              <sch:assert test="$docStatus = $firstChangeWithDocStatus/@docStatus">
                                 ERROR: The docStatus of the revisionDesc must match the latest change/@docStatu
                              </sch:assert>
                              <sch:assert test="$metaStatus = $firstChangeWithMetaStatus/@metaStatus">
                                 ERROR: The metaStatus of the revisionDesc must match the latest change/@metaStatus
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="revisionDescEarliest" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc[count(tei:change[@when]) gt 1]">
                              <sch:let name="firstChange" value="tei:change[1]"/>
                              <sch:let name="secondChange" value="tei:change[2]"/>
                              <sch:let name="firstDate" value="xs:date(string-join((tokenize($firstChange/@when,'-'),'01','01')[position() lt 4],'-'))"/>
                              <sch:let name="secondDate" value="xs:date(string-join((tokenize($firstChange/@when,'-'),'01','01')[position() lt 4],'-'))"/>
                              <sch:assert test="($firstDate gt $secondDate) or ($firstDate = $secondDate)">
                                 ERROR: Change elements should be ordered reverse chronologically (latest first).
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="textClass" module="header" mode="change">
                  <!--Add constraints to force either a correspDesc or a settingDesc-->
               </elementSpec>
               <moduleRef key="figures" include="cell figDesc figure row table"/>
               <moduleRef key="gaiji" include="char charDecl g localProp mapping"/><elementSpec ident="g" module="gaiji" mode="change">
                  <attList>
                     <attDef ident="ref" mode="change" usage="req">
                        <datatype>
                           <dataRef key="limdata.glyph"/>
                        </datatype>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>In most cases, the <gi>noteMarker</gi> element is more appropriate,
                     except in cases where the marker is in another hand; in that case, use the g
                     element.</p>
                  </remarks>
               </elementSpec>
               <moduleSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim"/><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="compliment" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="compliments" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="compliment" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="duration" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                  </classes>
                  <content>
                     <macroRef key="macro.paraContent"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="enclosure" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="enclosures" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="enclosure" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="limItem" module="lim" mode="add">
                  <desc>contains a set of descriptional elements for a text that serves as the basis for a containing text.</desc>
                  <classes>
                     <memberOf key="att.typed"/>
                  </classes>
                  <content>
                     <sequence preserveOrder="false">
                        <alternate>
                           <elementRef key="correspDesc" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="settingDesc" minOccurs="0" maxOccurs="1"/>
                        </alternate>
                        <elementRef key="creation" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="noteGrp" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="date" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="author" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="limItem" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="bibl" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                  </content>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList type="closed" mode="add">
                           <valItem ident="poemSongEpitaph" mode="add">
                              <gloss>poem / song / epitaph</gloss>
                              <desc>poem / song / epitaph</desc>
                           </valItem>
                           <valItem ident="letter" mode="add">
                              <desc>letter</desc>
                              <gloss>letter</gloss>
                           </valItem>
                           <valItem ident="accountNarrative" mode="add">
                              <desc>account / narrative</desc>
                              <gloss>account / narrative</gloss>
                           </valItem>
                           <valItem ident="speech" mode="add">
                              <desc>speech</desc>
                              <gloss>speech</gloss>
                           </valItem>
                           <valItem ident="conversation" mode="add">
                              <desc>conversation</desc>
                              <gloss>conversation</gloss>
                           </valItem>
                           <valItem ident="insert" mode="add">
                              <desc>insert</desc>
                              <gloss>insert</gloss>
                           </valItem>
                           <valItem ident="misc" mode="add">
                              <desc>miscellaneous</desc>
                              <gloss>miscellaneous</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="NB" mode="add" module="lim">
                  <gloss>nota bene</gloss>
                  <desc>groups together content that is marked as a nota bene.</desc>
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.written"/>
                     <memberOf key="model.divPart"/>
                     <memberOf key="model.divBottomPart"/>
                  </classes>
                  <content>
                     <sequence>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.global"/>
                           <classRef key="model.divTopPart"/>
                        </alternate>
                        <classRef key="model.common"/>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.global"/>
                           <classRef key="model.common"/>
                        </alternate>
                        <sequence minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.divBottomPart"/>
                           <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                     </sequence>
                  </content>
                  <remarks>
                     <p>The <gi>NB</gi> element is modelled after the <gi>postscript</gi> element
                        as Forbes frequently uses NBs in multiple contexts (including as trailing 
                        content, or as the entirety of an element).</p>
                     <p>When a NB is used as the content of a footnote, 
                        wrap the <gi>NB</gi> in the <gi>note</gi>.</p>
                     <p>We assume that all <gi>NB</gi> elements are written by Forbes (i.e. the implied value of <att>resp</att> is prs:FORBR1).</p>
                  </remarks>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="noteMarker" mode="add" module="lim">
                  <classes>
                     <memberOf key="model.milestoneLike"/>
                  </classes>
                  <content>
                     <textNode/>
                  </content>
                  <constraintSpec ident="noteMarker.mustHaveTargetInNote" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note/tei:noteMarker | tei:note/tei:supplied/tei:noteMarker">
                              <sch:assert test="@target">ERROR: Note markers in a note should have a target
                                 pointing to the source note marker.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:noteMarker[not(parent::tei:note)] | tei:noteMarker[not(parent::tei:supplied/parent::tei:note)]">
                              <sch:assert test="@xml:id">ERROR: Note markers in the body of text should 
                              have an xml:id identifying it. (This should be automatic if you use
                              the keyboard shortcut Command + Shift + N)</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.allTargetsShouldStartWithHash" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:noteMarker[@target]">
                              <sch:let name="localTargs" value="tokenize(@target,'\s+')"/>
                              <sch:assert test="every $targ in $localTargs satisfies matches($targ,'^(doc:[^#]+)?#')">ERROR: Every target in noteMarker must start with a '#' or a "doc:" pointer with a hash reference.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.allTargsShouldExist" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:noteMarker[@target]">
                              <sch:let name="noteMarker" value="."/>
                              <sch:let name="localTargs" value="tokenize(@target,'\s+')[matches(.,'^#')]"/>
                              <sch:let name="noteMarkers" value="ancestor::tei:TEI/descendant::tei:noteMarker[@xml:id]"/>
                              <sch:let name="badPointers" value="for $targ in $localTargs return                                  let $note := $noteMarkers[@xml:id = substring-after($targ,'#')]                                  return if (exists($note) and $note[. &lt;&lt; $noteMarker]) then ()                                  else $targ"/>
                               <sch:assert test="empty($badPointers)">ERROR: Cannot find preceding noteMarker for target<sch:value-of select="if (count($badPointers) gt 1) then 's' else ()"/>: <sch:value-of select="string-join($badPointers,' ')"/>.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.mustHaveContentIfUnknown" scheme="schematron">
                     <constraint>
                        
                        <sch:rule context="tei:noteMarker[@ref='g:UNKNOWN']">
                           <sch:assert test="matches(string(.), '\S')">ERROR: You must provide a character in the noteMarker when using g:UNKNOWN</sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:noteMarker[@ref][not(@ref = 'g:UNKNOWN')]">
                           <sch:assert test="empty(text())">ERROR: No text content is allowed in noteMarker unless @ref='g:UNKNOWN'</sch:assert>
                        </sch:rule>
                        
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.mustHaveIdFollowingFormat" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:noteMarker[not(parent::tei:note[@anchored='true'] or parent::tei:supplied/parent::tei:note[@anchored='true'])]">
                           <sch:let name="prePage" value="preceding::tei:pb[1]"/>
                           <sch:let name="prePageVal" value="if ($prePage) then substring-after($prePage/@facs,'pg:') else tokenize(ancestor::tei:TEI/@xml:id,'\.')[2]"/>
                           <sch:let name="prePageInt" value="xs:integer($prePageVal)"/>
                           <sch:let name="preNotes" value="preceding::tei:noteMarker[@xml:id]"/>
                           <sch:let name="noteNum" value="(if (exists($prePage)) then count($preNotes[. &gt;&gt; $prePage]) else count($preNotes)) + 1"/>
                           <sch:let name="noteMarkerId" value="'p' || $prePageVal || '_n' || $noteNum"/>
                           <sch:assert test="@xml:id and (@xml:id = $noteMarkerId)">ERROR: @xml:id of noteMarker should be <sch:value-of select="$noteMarkerId"/>.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <!--Identical to the ref on glyph-->
                     <attDef ident="ref" usage="req">
                        <desc versionDate="2005-01-14" xml:lang="en">points to a description of the character or glyph intended.</desc>
                        <desc versionDate="2007-05-02" xml:lang="zh-TW">連結到該文字或字體的描述。</desc>
                        <desc versionDate="2008-04-05" xml:lang="ja">当該文字やグリフの解説を参照する．</desc>
                        <desc versionDate="2007-06-12" xml:lang="fr">pointe vers la description du caractère ou du glyphe
                            visé</desc>
                        <desc versionDate="2007-05-04" xml:lang="es">indica la descripción del carácter o pictograma dado.</desc>
                        <desc versionDate="2007-01-21" xml:lang="it">punta a una descrizione del carattere o glifo.</desc>
                        <datatype>
                           <dataRef key="limdata.glyph"/>
                        </datatype>
                     </attDef>
                     <attDef ident="annotation" usage="opt">
                        <desc>describes any penciled annotation surrounding this note marker</desc>
                        <valList type="closed">
                           <valItem ident="circle">
                              <gloss>circle</gloss>
                              <desc>circled in pencil</desc>
                           </valItem>
                           <valItem ident="strike">
                              <gloss>strike</gloss>
                              <desc>Struck out in pencil</desc>
                           </valItem>
                        </valList>
                        <remarks>
                           <p>This <att>annotation</att> attribute is something of a shortcut 
                           for the <gi>add</gi> element to better describe some kind of phenomena around
                           a note marker added by a later annotator.</p>
                        </remarks>
                     </attDef>
                     <attList org="choice">
                        <attDef ident="xml:id" usage="rec">
                           <gloss versionDate="2007-07-02" xml:lang="en">identifier</gloss>
                           <gloss versionDate="2007-12-20" xml:lang="ko">확인소</gloss>
                           <gloss versionDate="2008-04-06" xml:lang="es">identificador</gloss>
                           <gloss versionDate="2008-03-30" xml:lang="fr">identifiant</gloss>
                           <gloss versionDate="2007-11-06" xml:lang="it">identificatore</gloss>
                           <gloss xml:lang="ja" versionDate="2019-06-08">識別子</gloss>
                           <desc versionDate="2005-10-10" xml:lang="en">provides a unique identifier for the element bearing the attribute.</desc>
                           <desc versionDate="2007-12-20" xml:lang="ko">속성을 포함하는 요소에 대한 고유한 확인소를 제공한다.</desc>
                           <desc versionDate="2007-05-02" xml:lang="zh-TW">提供一個獨特識別符碼，識別帶有該屬性的元素。</desc>
                           <desc versionDate="2008-04-05" xml:lang="ja">当該要素にユニークな識別子を示す．</desc>
                           <desc versionDate="2009-05-25" xml:lang="fr">fournit un identifiant unique pour l'élément qui
                              porte l'attribut</desc>
                           <desc versionDate="2007-05-04" xml:lang="es">proporciona un identificador único para el elemento
                              al cual se asocia el atributo.</desc>
                           <desc versionDate="2007-01-21" xml:lang="it">assegna un identificatore unico all'elemento a cui è
                              associato l'attributo</desc>
                           <datatype><dataRef name="ID"/></datatype>
                           <remarks versionDate="2005-10-10" xml:lang="en">
                              <p>The <att>xml:id</att> attribute may be used to specify a canonical reference for an
                                 element; see section <ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="fr" versionDate="2007-06-12">
                              <p>L'attribut <att>xml:id</att> peut être employé pour indiquer une référence canonique pour
                                 un élément ; voir la section<ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="es" versionDate="2008-04-06">
                              <p>El atributo <att>xml:id</att> se puede utilizar para especificar una referencia canónica
                                 para un elemento; ver la sección <ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="ja" versionDate="2008-04-05">
                              <p> 当該属性<att>xml:id</att>は，属性の指示対象を示している．詳細 は<ptr target="#CORS"/>を参照のこと． </p>
                           </remarks>
                        </attDef>
                        <attDef ident="target" usage="req">
                           <desc versionDate="2010-05-02" xml:lang="en">specifies the destination of the reference by supplying one or more URI References</desc>
                           <desc versionDate="2007-12-20" xml:lang="ko">하나 혹은 다수의 URI 참조를 제시하여 참조의 목적지를 명시한다.</desc>
                           <desc versionDate="2007-05-02" xml:lang="zh-TW">用一個或多個統一資源識別符參照 (URI References) 來說明參照所指位置。</desc>
                           <desc versionDate="2008-04-05" xml:lang="ja">ひとつ以上のURIで，参照先を特定する．</desc>
                           <desc versionDate="2009-01-06" xml:lang="fr">précise la cible de la référence en donnant une ou
                              plusieurs références URI</desc>
                           <desc versionDate="2007-05-04" xml:lang="es">especifica la destinación de una referencia
                              proporcionando una o más referencias URI.</desc>
                           <desc versionDate="2007-01-21" xml:lang="it">specifica la destinazione di un riferimento, fornendo
                              uno o più riferimenti URI</desc>
                           <datatype maxOccurs="unbounded"><dataRef key="teidata.pointer"/></datatype>
                           <remarks versionDate="2007-01-21" xml:lang="en"><p>One or more syntactically valid URI references, separated by whitespace. Because
                              whitespace is used to separate URIs, no whitespace is permitted inside a single URI. If a
                              whitespace character is required in a URI, it should be escaped with the normal mechanism,
                              e.g. <code>TEI%20Consortium</code>.</p></remarks>
                           <remarks versionDate="2007-01-21" xml:lang="fr"><p>Une ou plusieurs références URI syntaxiquement valables, séparée par
                              un espace. Puisqu'un espace  est employé pour séparer des URIs, aucun espace
                              n’est autorisé à l'intérieur d'un URI. Si un espace est requis dans un URI, il
                              faut le représenter avec une séquence d'échappement, comme par exemple 
                              <code>TEI%20Consortium</code>.</p></remarks>
                        </attDef>
                     </attList>
                  </attList>
                  
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="request" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="requests" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="request" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="scaffold" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                     <memberOf key="lim.att.locatable"/>
                  </classes>
                  <content>
                     <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="scaffold.mustHaveTrialPlace" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:scaffold[@value = 'true']">
                              <sch:assert test="tei:placeName or @where">
                      ERROR: If this is a scaffold speech, then it must have a place associated
                      for the location of the execution (either using a @where or a child placeName element).
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="value">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                     <attDef ident="where" mode="change">
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                        <valList mode="add" type="semi">
                           <valItem ident="plc:TOWE1" mode="add">
                              <desc>Tower of London</desc>
                              <gloss>Tower of London</gloss>
                           </valItem>
                           <valItem ident="plc:KENN1" mode="add">
                              <desc>Kennington Common</desc>
                              <gloss>Kennington Common</gloss>
                           </valItem>
                           <valItem ident="plc:CARL2" mode="add">
                              <desc>Carlisle</desc>
                              <gloss>Carlisle</gloss>
                           </valItem>
                           <valItem ident="plc:BRAM1" mode="add">
                              <desc>Brampton</desc>
                              <gloss>Brampton</gloss>
                           </valItem>
                           <valItem ident="plc:PENR1" mode="add">
                              <desc>Penrith</desc>
                              <gloss>Penrith</gloss>
                           </valItem>
                           <valItem ident="plc:YORK1" mode="add">
                              <desc>York</desc>
                              <gloss>York</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="rule" module="lim" mode="add">
                  <gloss>rule</gloss>
                  <desc>marks a ruled line</desc>
                  <classes>
                     <memberOf key="model.milestoneLike"/>
                     <memberOf key="att.milestoneUnit"/>
                  </classes>
                  <content>
                     <elementRef key="desc" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="rule.onlyPlaceWithExtentLessThan100" scheme="schematron">
                     <desc>The <att>place</att> attribute only makes sense when extent is less than 100%</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:rule[@place]">
                              <sch:assert test="exists(@extent) and xs:integer(replace(@extent,'%','')) lt 100">ERROR: @place only makes sense if an @extent exists and is less than 100%.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="rule.extentShouldBeIntegerLeq100" scheme="schematron">
                     <desc>The <att>extent</att> of a <gi>rule</gi> should be between 1 and 100%</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:rule[@extent]">
                              <sch:let name="int" value="xs:integer(replace(@extent,'%',''))"/>
                              <sch:assert test="$int = (1 to 100)">ERROR: @extent should be a percentage value between 1 and 100.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="rule.usedToUseMilestone" scheme="schematron">
                     <desc>We used to use the milestone element, but that construct is now deprecated.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:milestone">
                              <sch:assert test="not(ancestor::tei:text)">ERROR: milestone elements for ruled lines are deprecated. Use &lt;rule&gt; instead.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="unit" usage="req" mode="change">
                        <valList mode="replace">
                           <valItem ident="section">
                              <gloss>section</gloss>
                              <desc>a rule separating sections of some sort on
                                 the page, but not between items.</desc>
                           </valItem>
                           <valItem ident="item">
                              <gloss>item</gloss>
                              <desc>a rule that separates items.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="extent" usage="opt">
                        <desc>the extent of the rule in percentage. By default, 100%.</desc>
                        <datatype>
                           <dataRef name="token" restriction="\d+%"/>
                        </datatype>
                        <defaultVal>100%</defaultVal>
                        <valList type="semi">
                           <valItem ident="25%">
                              <gloss>25%</gloss>
                              <desc>A quarter of the page</desc>
                           </valItem>
                           <valItem ident="50%">
                              <gloss>50%</gloss>
                              <desc>Half of the page</desc>
                           </valItem>
                           <valItem ident="75%">
                              <gloss>75%</gloss>
                              <desc>Three-quarters of the page</desc>
                           </valItem>
                           <valItem ident="100%">
                              <gloss>100%</gloss>
                              <desc>The entire width of the page.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="place" usage="opt">
                        <desc>specifies where this item is placed.</desc>
                        <valList type="closed">
                           <valItem ident="left">
                              <gloss>left</gloss>
                              <desc>left</desc>
                           </valItem>
                           <valItem ident="right">
                              <gloss>right</gloss>
                              <desc>right</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="rendition" usage="opt">
                        <desc>Rendition</desc>
                        <valList type="closed">
                           <valItem ident="rnd:dashed">
                              <gloss>a dashed line</gloss>
                              <desc>a dashed line</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>This element is semantically equivalent to the standard TEI <gi>milestone</gi> with <att>rendition</att> values. However, it may contain an optional <gi>desc</gi> child if further description of line is necessary.</p>
                     <p>The <att>place</att> attribute (which is borrowed from att.placement) has no bearing on <gi>rule</gi> elements that do not specify an <att>extent</att> less than 100% (which is the default).</p>
                  </remarks>
               </elementSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.boolean" mode="add" module="lim" type="atts">
                  <attList>
                     <attDef ident="value" usage="rec">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.global.fragmentable" mode="add" module="lim" type="atts">
                  <desc versionDate="2021-08-22" xml:lang="en">provides attributes for representing
                     fragmentation of a structural element, typically as 
                     a consequence of some overlapping hierarchy.</desc>
                  <attList>
                     <attDef ident="part" usage="opt">
                        <desc versionDate="2013-06-21" xml:lang="en">specifies whether or not its parent element is fragmented
                           in some way, typically by some other overlapping structure: for
                           example a speech which is divided between two or more verse
                           stanzas, a paragraph which is split across a page division, a
                           verse line which is divided between two speakers.</desc>
                        <datatype>
                           <dataRef key="teidata.enumerated"/>
                        </datatype>
                        <valList type="closed">
                           <valItem ident="Y">
                              <gloss versionDate="2013-01-07" xml:lang="en">yes</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">はい</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">the element is fragmented in some (unspecified) respect</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">要素はいくつかの（不特定の）点で断片化されている。</desc>
                           </valItem>
                           <valItem ident="N">
                              <gloss versionDate="2013-01-07" xml:lang="en">no</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">いいえ</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">the element is not fragmented, or no claim is made as to its completeness</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">要素が断片化されていないか，または完全性についての主張はない。</desc>
                           </valItem>
                           <valItem ident="I">
                              <gloss versionDate="2013-01-07" xml:lang="en">initial</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">最初の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is the initial part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の最初の部分を示す。</desc>
                           </valItem>
                           <valItem ident="M">
                              <gloss versionDate="2013-01-07" xml:lang="en">medial</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">中間の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is a medial part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の中間の部分を示す。</desc>
                           </valItem>
                           <valItem ident="F">
                              <gloss versionDate="2013-01-07" xml:lang="en">final</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">最後の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is the final part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の最後の部分を示す。</desc>
                           </valItem>
                        </valList>
                        <remarks versionDate="2013-01-07" xml:lang="en">
                           <p>The values <val>I</val>, <val>M</val>, or <val>F</val>
                              should be used only where it is clear how the element may
                              be reconstituted.</p>
                        </remarks>
                        <remarks xml:lang="ja" versionDate="2019-06-08">
                           <p>
                              <val>I</val>，<val>M</val>，または<val>F</val>という値は，要素の再構成方法が明らかな場合にのみ使用する。</p>
                        </remarks>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>The same as TEI's att.fragmentable, but turned into its own class
                     to make it global.</p>
                  </remarks>
               </classSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.locatable" module="lim" type="atts" mode="add">
                  <classes>
                     <memberOf key="lim.att.locatable.directed"/>
                  </classes>
                  <attList>
                     <attDef ident="where" usage="opt">
                        <desc versionDate="2007-06-11" xml:lang="en">indicates the location of an event by pointing to a <gi>place</gi> element</desc>
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.locatable.directed" module="lim" type="atts" mode="add">
                  <attList>
                     <attDef ident="toWhere" usage="opt">
                        <desc>indicates the location of something being sent.</desc>
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><macroSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.personMacro" module="lim" mode="add">
                  <content>
                    <sequence>
                       <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
                       <!--NOTE: preserveORder doesn't actually work, but there
                may be a new element coming: see
                https://github.com/TEIC/TEI/issues/2154 -->
                       <sequence preserveOrder="false">
                          <elementRef key="sex" minOccurs="0" maxOccurs="1"/>
                          <elementRef key="birth" minOccurs="0" maxOccurs="1"/>
                          <elementRef key="death" minOccurs="0" maxOccurs="1"/>
                          <elementRef key="faith" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="affiliation" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="occupation" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="nationality" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="residence" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="figure" minOccurs="0" maxOccurs="unbounded"/>
                       </sequence>
                       <!--Always make langKnowledge and note come last-->
                       <elementRef key="langKnowledge" minOccurs="0" maxOccurs="1"/>
                       <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                    </sequence> 
                  </content>
               </macroSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.ana" mode="add">
                  <desc>Datatype for all analytic pointers</desc>
                  <content>
                     <valList>
                        <valItem ident="lim:women">
                           <desc>women</desc>
                           <gloss>women</gloss>
                        </valItem>
                        <valItem ident="lim:gaelic">
                           <desc>gaelic</desc>
                           <gloss>gaelic</gloss>
                        </valItem>
                        <valItem ident="lim:media">
                           <desc>media</desc>
                           <gloss>media</gloss>
                        </valItem>
                        <valItem ident="lim:class">
                           <desc>class</desc>
                           <gloss>class</gloss>
                        </valItem>
                     </valList>
                  </content>
               </dataSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.facs" mode="add">
                  <desc>Datatype for all lim facsimile pointers.</desc>
                  <content>
                     <dataRef name="token" restriction="(lib|pg):\d+(.\d+)?"/>
                  </content>
               </dataSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.glyph" mode="add">
                  <desc>Datatype for all glyph pointers.</desc>
                  <content>
                     <valList type="closed">
                     </valList>
                  </content>
               </dataSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.placement" mode="add">
                  <desc>Possible values for placement.</desc>
                  <content>
                     <valList type="closed">
                        <valItem ident="bottom">
                           <gloss>bottom</gloss>
                           <desc>at the foot of the page</desc>
                        </valItem>
                        <valItem ident="left" mode="add">
                           <gloss>left</gloss>
                           <desc>in the left margin</desc>
                        </valItem>
                        <valItem ident="center" mode="add">
                           <gloss>center</gloss>
                           <desc>in the center</desc>
                        </valItem>
                        <valItem ident="right" mode="add">
                           <gloss>right</gloss>
                           <desc>in the right margin</desc>
                        </valItem>
                        <valItem ident="above" mode="add">
                           <gloss>above</gloss>
                           <desc>above the line</desc>
                        </valItem>
                        <valItem ident="below" mode="add">
                           <gloss>below</gloss>
                           <desc>below the line</desc>
                        </valItem>
                        <valItem ident="inline" mode="add">
                           <gloss>inline</gloss>
                           <desc>an inline note</desc>
                        </valItem>
                     </valList>
                  </content>
               </dataSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="fwPbConstraints" module="lim" mode="add" scheme="schematron">
                  <desc>Set of constraints for formeworks and page beginnings.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:fw | tei:pb">
                           <sch:assert test="parent::tei:ab | parent::tei:back | parent::tei:body | parent::tei:div | parent::tei:front | parent::tei:list | parent::tei:p | parent::tei:text | parent::tei:q | parent::tei:note | parent::tei:lg | parent::tei:head | parent::tei:NB | parent::tei:closer | parent::tei:dateline | parent::tei:signed">
                              ERROR: <sch:name/> should not appear within <sch:value-of select="local-name(parent::*)"/>.
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:fw">
                           <sch:assert test="not(tei:lb)">ERROR: <sch:name/> should not contain line beginnings 
                              (since they are usually a single line)</sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" scheme="schematron" ident="global.rootIdMustMatchDocument">
                  <desc>The rootid must be the same as the document's name.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="/tei:*">
                           <sch:let name="rootEl" value="local-name()"/>
                           <sch:let name="correctDir" value="                     if (self::tei:person and @role='contributor') then 'contributors'                     else if (self::tei:person) then 'people'                     else if (self::tei:place) then 'places'                     else if (self::tei:org) then 'orgs'                     else $dirName"/>
                           <sch:assert test="$basename = $id">
                    ERROR: Document's @xml:id (<sch:value-of select="$id"/>) must match the document's base filename
                    (<sch:value-of select="$basename"/>)
                  </sch:assert>
                           <sch:assert test="$dirName = $correctDir">
                    ERROR: All <sch:value-of select="if (self::person/@role) then @role else local-name()"/> files should added to the <sch:value-of select="$correctDir"/> folder. This file (<sch:value-of select="$id"/>) is in the <sch:value-of select="$dirName"/> folder.
                  </sch:assert>
                           <!--<sch:rule context="/tei:person[not(@role='contributor')]">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All people should be added to the /people/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:person[@role='contributor']">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All contributors should be added to the /contributors/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:org">
                    <sch:assert test="$dirName = 'orgs'">
                      ERROR: All orgs should be added to the /orgs/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:place">
                    <sch:assert test="$dirName = 'places'">
                      ERROR: All places should be added to the /places/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>-->
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" scheme="schematron" ident="global.variables">
                  <desc>Global variables for use across the schematron.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:let name="id" value="/tei:*/@xml:id"/>
                        <sch:let name="uri" value="document-uri(/)"/>
                        <sch:let name="tokens" value="tokenize($uri,'[/\\]')"/>
                        <sch:let name="basename" value="replace($tokens[last()],'\.xm[l_]$','')"/>
                        <sch:let name="dirName" value="$tokens[last() - 1]"/>
                        <sch:let name="placeIdPattern" value="'[A-Z]{4}\d+'"/>
                        <sch:let name="orgIdPattern" value="'[A-Z]{4}\d+(_[^_]+)*'"/>
                        <sch:let name="persIdPattern" value="'[A-Z]{5}\d+'"/>
                        <sch:let name="cutoff" value="xs:date('1752-09-02')"/>
                        <sch:let name="root" value="root(.)"/>
                        <sch:let name="docStatus" value="//tei:revisionDesc/@docStatus"/>
                        <sch:let name="isBornDigital" value="exists($root//tei:catRef[matches(@target,'bornDigital')])"/>
                        <sch:let name="isItem" value="exists($root//tei:limItem)"/>
                        <!-- <sch:let name="pd" value="replace($uri,'^(.+[/\\]lim-tei[\\/]).+$', '$1')"/>
                <sch:let name="dataDir" value="replace($pd,'(.+(.))$','$1data$2')"/>
                <sch:let name="glyphs"
                  value="document($dataDir || 'glyphs.xml')//tei:glyph[@xml:id]"/> -->
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" scheme="schematron" ident="inlineElementsNoSpaces">
                  <desc>Inline elements should not begin or end with spaces.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:title | tei:num | tei:ref | tei:rs | tei:placeName[not(parent::tei:place)] | tei:persName[not(parent::tei:person)] | tei:objectName[not(parent::tei:object)] | tei:date[ancestor::tei:text] | tei:time[ancestor::tei:text]">
                           <sch:let name="text" value="string(.)"/>
                           <sch:assert test="not(matches($text, '^\s+|\s+$'))">
                    ERROR: <sch:name/> should not begin or end with spaces.
                  </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="metadataContraints" module="lim" mode="add" scheme="schematron">
                  <desc>Set of constraints for profileDesc / premediation.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:limItem">
                           <sch:let name="genre" value="@type"/>
                           <sch:assert test="if (matches($genre, 'letter','i')) then tei:correspDesc else true()">
                              ERROR: All letters must have a correspDesc.
                           </sch:assert>
                           <sch:assert test="if (matches($genre,'Speech|Account|Conversation','i')) then tei:settingDesc else true()">
                              ERROR: All <sch:value-of select="$genre"/> must have a settingDesc.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="textConstraints" module="lim" mode="add" scheme="schematron">
                  <desc>Set of constraints for text and punctuation</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:*[text()][matches(string-join(text(),''),'\S')][ancestor::tei:text][not(self::tei:metamark)][$docStatus=('draft','inProgress','proofed', 'readyForProof')]">
                           <sch:let name="string" value="string-join(text(),'')"/>
                           <sch:assert test="not(matches($string,'(--+)|(––+)'))">
                              ERROR: Do not use multiple hyphens or en-dashes to represent an em-dash (—).
                           </sch:assert>
                          <!-- <sch:assert test="not(matches(., $sq)) and not(ancestor::tei:code | ancestor::*:egXML)">
                              ERROR: Straight quotation marks should be replaced by curly ones
                           </sch:assert>-->
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <moduleRef key="linking" include="ab linkGrp ptr seg standOff"/><elementSpec ident="anchor" module="linking" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.rendition" mode="delete"/>
                     <memberOf key="att.global.change" mode="delete"/>
                     <memberOf key="att.global.analytic" mode="delete"/>
                     <memberOf key="att.global.source" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="delete"/>
                     <memberOf key="att.type" mode="delete"/>
                     <memberOf key="lim.att.global.fragmentable" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="xml:id" usage="req" mode="change"/>
                     <attDef ident="xml:space" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="seg" module="linking" mode="change">
                  <classes mode="replace">
                     <memberOf key="model.choicePart"/>
                  </classes>
                  <constraintSpec ident="seg.onlyAllowedInEllipsis" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:choice[tei:seg]">
                              <sch:assert test="parent::tei:supplied/parent::tei:ellipsis">
                                 ERROR: choice/seg is allowed ONLY within a supplied and ellipsis.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <remarks>
                     <p><gi>seg</gi> is allowed only within a <gi>choice</gi> (and only when the choice is within a supplied and metamark).</p>
                  </remarks>
               </elementSpec><elementSpec ident="standOff" module="linking" mode="change">
                  <constraintSpec ident="standoff.elementsMustUseCopyOfORHaveAPersName" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:standOff/tei:*[not(self::tei:listQuote)]/tei:*[not(self::tei:head)]">
                              <sch:assert test="@copyOf or tei:*">
                      ERROR: <sch:name/> elements need either a @copyOf that points to an existing <sch:name/> OR content.
                    </sch:assert>
                              <sch:assert test="not(@copyOf and tei:*)">
                      ERROR: <sch:name/> elements should have either a <sch:name/>Name element OR a @copyOf, but not both.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               <moduleRef key="msdescription" include="additional adminInfo collection custodialHist history locus locusGrp msContents msDesc msIdentifier msItem msName msPart objectDesc origin physDesc repository summary supportDesc surrogates"/><elementSpec ident="locus" module="msdescription" mode="replace">
                  <gloss xml:lang="en" versionDate="2007-06-12">locus</gloss>
                  <desc versionDate="2019-01-17" xml:lang="en" xml:id="locus.desc">defines a location within a manuscript, manuscript part, or other object typically 
                     as a (possibly discontinuous) sequence of folio references.</desc>
                  <constraintSpec ident="locus.rangesMustMakeSense" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:locus[@from and @to]">
                              <sch:let name="from" value="xs:integer(replace(@from,'[^\d]+',''))"/>
                              <sch:let name="to" value="xs:integer(replace(@to,'[^\d]+',''))"/>
                              <sch:assert test="$from lt ($to + 1)">
                                 ERROR: @to value should not be less than @from. If you need to specify
                                 a set of discontinuous pages (i.e. spanning across a pageGroup), use a locusGrp.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="PatonLocus.mustBeWithinBounds" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:locus[@type='Paton'][@n and @from and @to]">
                              <sch:let name="n" value="@n"/>
                              <sch:let name="max" value="if (@n = '1') then 382                                   else if (@n = '2') then 380 else 416"/>
                              <sch:let name="from" value="xs:integer(replace(@from,'[^\d]+',''))"/>
                              <sch:let name="to" value="xs:integer(replace(@from,'[^\d]+',''))"/>
                              <sch:assert test="$from lt ($max + 1)">
                                 ERROR: @from value out of range: Paton volume <sch:value-of select="$n"/> contains <sch:value-of select="$max"/> pages.
                              </sch:assert>
                              <sch:assert test="$to lt ($max + 1)">
                                 ERROR: @to value out of range: Paton volume <sch:value-of select="$n"/> contains <sch:value-of select="$max"/> pages.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList org="group">
                     <attDef ident="from" usage="req">
                        <gloss xml:lang="en" versionDate="2007-06-12">from</gloss>
                        <desc versionDate="2013-12-21" xml:lang="en">specifies the
                           starting point of the location in a normalized form, typically a
                           page number.</desc>
                        <datatype>
                           <dataRef key="teidata.word"/>
                        </datatype>
                     </attDef>
                     <attDef ident="to" usage="req">
                        <gloss xml:lang="en" versionDate="2007-06-12">to</gloss>
                        <desc versionDate="2013-12-21" xml:lang="en">specifies the
                           end-point of the location in a normalized form, typically as a
                           page number.</desc>
                        <datatype>
                           <dataRef key="teidata.word"/>
                        </datatype>
                     </attDef>
                     <attList org="choice">
                        <attList org="group">
                           <attDef ident="type" usage="req" mode="replace">
                              <valList type="closed">
                                 <valItem ident="Forbes" mode="add">
                                    <desc>Forbes</desc>
                                    <gloss>A Forbes page range</gloss>
                                 </valItem>
                              </valList>
                           </attDef>
                        </attList>
                        <attList org="group">
                           <attDef ident="type" usage="req" mode="replace">
                              <valList type="closed">
                                 <valItem ident="Paton" mode="add">
                                    <desc>Paton</desc>
                                    <gloss>A Paton page range</gloss>
                                 </valItem>
                              </valList>
                           </attDef>
                           <attDef ident="n" usage="req">
                              <gloss versionDate="2007-07-02" xml:lang="en">number</gloss>
                              <desc versionDate="2005-10-10" xml:lang="en">gives a number (or other label) for an element, which is not necessarily unique within
                                 the document.</desc>
                              <datatype maxOccurs="1">
                                 <dataRef name="positiveInteger">
                                    <dataFacet name="maxInclusive" value="3"/>
                                 </dataRef>
                              </datatype>
                              <remarks versionDate="2013-12-06" xml:lang="en">
                                 <p>The value of this attribute is always understood to be a single token, even if it contains space or other punctuation characters, and need not be composed of numbers only. It is typically used to specify the numbering of chapters, sections,
                                    list items, etc.; it may also be used in the specification of a standard reference system
                                    for the text.</p>
                              </remarks>
                           </attDef>
                        </attList>
                     </attList>
                  </attList>
               </elementSpec><elementSpec ident="locusGrp" module="msdescription" mode="change">
                  <constraintSpec ident="locusGrpVsLocus" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:locusGrp/tei:locus">
                              <sch:assert test="self::tei:locus[@type='Forbes']">
                                 ERROR: Every locus in a locusGrp must be of type "Forbes"
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               <moduleRef key="namesdates" include="addName affiliation birth death faith floruit forename genName geo langKnowledge langKnown listObject listOrg listPerson listPlace location nameLink nationality object objectName occupation org orgName persName person persona place placeName residence roleName settlement sex surname"/><elementSpec ident="affiliation" module="namesdates" mode="change">
                  <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlIdAndProperlyNested">
                     <desc>orgs must have an xml:id that follows the 4 letters and digit pattern, but may be nested.</desc>
                     <constraint>
                        <sch:rule context="tei:affiliation[@type=('clan','army')]">
                           <sch:assert test="matches(@ref,'org:')">ERROR: All <sch:value-of select="@type"/> affiliations must have a @ref that points to the org for that <sch:value-of select="@type"/>.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList type="closed" mode="replace">
                           <valItem ident="clan" mode="add">
                              <desc>clan</desc>
                              <gloss>clan</gloss>
                           </valItem>
                           <valItem ident="army" mode="add">
                              <desc>clan</desc>
                              <gloss>clan</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="birth" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.naming" mode="delete"/>
                     <memberOf key="att.canonical" mode="delete"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="death" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.naming" mode="delete"/>
                     <memberOf key="att.canonical" mode="delete"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="faith" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                     <attDef ident="ref" mode="change" usage="req">
                        <valList type="closed" mode="add">
                           <valItem ident="rel:ChurchOfScotland" mode="add">
                              <desc>Church of Scotland</desc>
                              <gloss>Church of Scotland</gloss>
                           </valItem>
                           <valItem ident="rel:Episcopalian" mode="add">
                              <desc>Episcopalian</desc>
                              <gloss>Episcopalian</gloss>
                           </valItem>
                           <valItem ident="rel:Anglican" mode="add">
                              <desc>Anglican</desc>
                              <gloss>Anglican</gloss>
                           </valItem>
                           <valItem ident="rel:RomanCatholic" mode="add">
                              <desc>Roman Catholic</desc>
                              <gloss>Roman Catholic</gloss>
                           </valItem>
                           <valItem ident="rel:BritishOrthodox" mode="add">
                              <desc>British Orthodox</desc>
                              <gloss>British Orthodox</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="langKnowledge" module="namesdates" mode="change">
                  <classes mode="replace">
                     <memberOf key="model.persStateLike"/>
                  </classes>
               </elementSpec><elementSpec ident="langKnown" module="namesdates" mode="change">
                  <classes mode="change">
              <!--Add @cert and @resp explicitly-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <attList>
              <!--We do not specify level of fluency-->
                     <attDef ident="level" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="listObject" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="object" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="listPerson" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="person" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="listPlace" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="place" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="nationality" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                  </classes>
                  <attList>
              <!--Remove @role, which is provided by att.naming,
                but att.naming is a superset of att.canonical,
                which we want for ref.-->
                     <attDef ident="role" mode="delete"/>
                     <attDef ident="ref" mode="change" usage="req">
                        <valList type="closed" mode="add">
                           <valItem ident="ntl:English" mode="add">
                              <desc>English</desc>
                              <gloss>English</gloss>
                           </valItem>
                           <valItem ident="ntl:French" mode="add">
                              <desc>French</desc>
                              <gloss>French</gloss>
                           </valItem>
                           <valItem ident="ntl:Spanish" mode="add">
                              <desc>Spanish</desc>
                              <gloss>Spanish</gloss>
                           </valItem>
                           <valItem ident="ntl:Irish" mode="add">
                              <desc>Irish</desc>
                              <gloss>Irish</gloss>
                           </valItem>
                           <valItem ident="ntl:Scottish" mode="add">
                              <desc>Scottish</desc>
                              <gloss>Scottish</gloss>
                           </valItem>
                           <valItem ident="ntl:Prussian" mode="add">
                              <desc>Prussian</desc>
                              <gloss>Prussian</gloss>
                           </valItem>
                           <valItem ident="ntl:Austrian" mode="add">
                              <desc>Austrian</desc>
                              <gloss>Austrian</gloss>
                           </valItem>
                           <valItem ident="ntl:Hanoverian" mode="add">
                              <desc>Hanoverian</desc>
                              <gloss>Hanoverian</gloss>
                           </valItem>
                           <valItem ident="ntl:Italian" mode="add">
                              <desc>Italian</desc>
                              <gloss>Italian</gloss>
                           </valItem>
                           <valItem ident="ntl:Dutch" mode="add">
                              <desc>Dutch</desc>
                              <gloss>Dutch</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="object" module="namesdates" mode="change">
                  <classes>
                     <memberOf key="att.docStatus" mode="delete"/>
                  </classes>
                  <content>
                     <sequence>
                        <elementRef key="objectName" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                   
                  </content>
                  <remarks mode="add">
                     <p>Our use of object is not TEI conformant, but the break is fairly
                trivial: where objectName is simply used
              instead of objectIdentifier/objectName.</p>
                  </remarks>
               </elementSpec><elementSpec ident="org" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
                     <sequence>
                        <!--Orgs must have an orgName-->
                        <elementRef key="orgName" minOccurs="1" maxOccurs="unbounded"/>
                        <!--Also needs a note-->
                        <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                        <!--And may include a ptrGrp-->
                        <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                        <!--And may have a list of suborganizations below it-->
                        <elementRef key="listOrg" minOccurs="0" maxOccurs="1"/>
                     </sequence>
            
                  </content>
                  <attList>
                     <attDef ident="xml:id" mode="change" usage="req">
                        <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlId">
                           <desc>orgs must have an xml:id that follows the 4 letters and digit pattern, but may be nested.</desc>
                           <constraint>
                              <sch:rule context="/tei:org">
                                 <sch:assert test="matches(@xml:id, concat('^', $orgIdPattern, '$'))">ERROR: All main orgs must have an id that is a sequence of four letter and a digit.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                        <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlIdProperlyNested">
                           <desc>org ids must be inherited.</desc>
                           <constraint>
                              <sch:rule context="tei:org/tei:listOrg/tei:org">
                                 <sch:let name="parentId" value="ancestor::tei:org[1]/@xml:id"/>
                                 <sch:assert test="starts-with(@xml:id, $parentId)">ERROR: All sub organization ids must start with the id of its parent organization.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="orgName" module="namesdates" mode="change">
                  <constraintSpec ident="orgName.mustHaveRefWithOrg" mode="add" scheme="schematron">
                     <desc>All inline placeNames must have a ref that points to the place db.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:orgName[not(parent::tei:org)][@ref]">
                           <sch:let name="ptr" value="(@ref, @where)[1]"/>
                           <sch:assert test="matches($ptr ,concat('^org:', $orgIdPattern, '$'))">ERROR: All <sch:name/> pointers must have an @<sch:value-of select="local-name($ptr)"/> that begins with "org:" followed by 4 uppercase letters and a number (e.g. org:CLAN1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="persName" module="namesdates" mode="change">
                  <constraintSpec ident="persName.mustHaveRefWithPrs" mode="add" scheme="schematron">
                     <desc>All inline persNames must have a ref that points to the personography db.</desc>
                     <constraint>
                 <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:persName[not(parent::tei:person)][@ref]">
                           <sch:assert test="matches(@ref,concat('^prs:', $persIdPattern, '$'))">ERROR: All persName pointers must have an @ref that begins with "prs:" followed by 5 uppercase letters and a number (e.g. prs:FORBR1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="persName.dontUseRoleName" mode="add" scheme="schematron">
                     <desc>Do not use roleName, but use occupation instead.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:persName/tei:roleName">
                           <sch:assert test="false()">ERROR: Rolenames should not be denoted in a persName directly; all role information should be encoded using the occupation element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="person" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
                     <sequence>
                        <macroRef key="lim.personMacro"/>
                        <!--Add linkGrp optionally only for person, not persona-->
                        <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                 
                  </content>
                  <constraintSpec ident="person.constraints" scheme="schematron">
                     <desc>Various constraints for the different models for contributors and non-contributors.</desc>
                     <constraint>
                        <sch:rule context="/tei:person[not(@role='contributor')]">
                           <sch:assert test="matches(@xml:id,concat('^', $persIdPattern, '$'))">ERROR: All people must have an @xml:id of 5 uppercase letters and a number (e.g. FORBR1).</sch:assert>
                           <sch:assert test="tei:langKnowledge">ERROR: People must contain a langKnowledge element.</sch:assert>
                        </sch:rule>
                        <sch:rule context="/tei:person[@role='contributor']">
                           <sch:assert test="matches(@xml:id, '^[A-Z]{2,3}\d+$')">ERROR: All contributors must have an @xml:id of 2-3 uppercase letters and a number (e.g. LD1).</sch:assert>
                           <sch:assert test="tei:persName and tei:note">ERROR: Contributors should only contain persName and note.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="age" mode="delete"/>
                     <!--Remove @sex, since we use the element instead-->
                     <attDef ident="sex" mode="delete"/>
                     <attDef ident="role" mode="change">
                        <valList>
                           <valItem ident="contributor" mode="add">
                              <desc>contributor</desc>
                              <gloss>a contemporary contributor to the Lyon in Mourning project</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="persona" module="namesdates" mode="change">
                  <content>
                     <macroRef key="lim.personMacro"/>
                  </content>
               </elementSpec><elementSpec ident="place" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.rendition" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                     <memberOf key="att.global.analytic" mode="delete"/>
                     <memberOf key="att.global.source" mode="delete"/>
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
                     <sequence>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="location" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                  </content>
                  <constraintSpec ident="place.mustHaveProperId" scheme="schematron">
                     <desc>All people must have a proper id.</desc>
                     <constraint>
                        <sch:rule context="/tei:place">
                           <sch:assert test="matches(@xml:id,concat('^', $placeIdPattern, '$'))">ERROR: All places must have an @xml:id of 4 uppercase letters and a number (e.g. LEIT1).</sch:assert>
                           <sch:assert test="tei:placeName">ERROR: All places must have a placeName.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="placeName" module="namesdates" mode="change">
                  <constraintSpec ident="placeName.mustHaveRefWithPlc" mode="add" scheme="schematron">
                     <desc>All inline placeNames must have a ref that points to the place db.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:placeName[not(parent::tei:place)][@ref] | tei:*[@where]">
                           <sch:let name="ptr" value="(@ref, @where)[1]"/>
                           <sch:assert test="matches($ptr ,concat('^plc:', $placeIdPattern, '$'))">ERROR: All <sch:name/> pointers must have an @<sch:value-of select="local-name($ptr)"/> that begins with "plc:" followed by 4 uppercase letters and a number (e.g. plc:LEIT1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="residence" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <!--Add custom att.locatable-->
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.naming" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="sex" module="namesdates" mode="change">
                  <classes>
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="val" mode="change" usage="req"/>
                     <attDef ident="calendar" mode="delete"/>
                     <attDef ident="type" mode="delete"/>
                  </attList>
               </elementSpec><classSpec ident="att.datable.custom" module="namesdates" type="atts" mode="change">
                  <attList>
                     <attDef ident="datingPoint" mode="delete"/>
                  </attList>
               </classSpec>
               <moduleRef key="tei"/><classSpec ident="att.anchoring" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="targetEnd" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.breaking" type="atts" module="tei" mode="delete"/><classSpec ident="att.cReferencing" module="tei" type="atts" mode="delete"/><classSpec ident="att.canonical" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="key" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.damaged" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="group" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.datable" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="period" mode="delete"/>
                  </attList>
                  
               </classSpec><classSpec ident="att.datable.iso" module="tei" type="atts" mode="delete"/><classSpec ident="att.datcat" module="tei" type="atts" mode="delete"/><classSpec ident="att.declarable" module="tei" type="atts" mode="delete"/><classSpec ident="att.declaring" module="tei" type="atts" mode="delete"/><classSpec ident="att.divLike" module="tei" type="atts" mode="delete"/><classSpec ident="att.docStatus" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="status" mode="delete"/>
                     <attDef ident="docStatus" mode="add" usage="opt">
                        <desc versionDate="2010-05-06" xml:lang="en">describes the status of the transcription at the time indicated.</desc>
                        <valList type="closed" mode="add">
                           <valItem ident="empty" mode="add">
                              <desc>transcription empty</desc>
                              <gloss>empty / not yet worked on or edited</gloss>
                           </valItem>
                           <valItem ident="uneditedTranscription" mode="add">
                              <desc>Converted and unedited transcription</desc>
                              <gloss>The transcription has been converted from a word doc (or similar)
                              and has yet to be edited.</gloss>
                           </valItem>
                           <valItem ident="uneditedHTR" mode="add">
                              <desc>HTR transcription unedited</desc>
                              <gloss>transcription has not yet been edited from the conversion
                              from Transkribus</gloss>
                           </valItem>
                           <valItem ident="inProgress" mode="add">
                              <desc>transcription in progress</desc>
                              <gloss>currently being worked on, but not yet "done"</gloss>
                           </valItem>
                           <valItem ident="readyForProof" mode="add">
                              <desc>transcription ready for proof</desc>
                              <gloss>corrected and encoded, and is now ready to be proofed</gloss>
                           </valItem>
                           <valItem ident="proofed" mode="add">
                              <desc>transcription proofed</desc>
                              <gloss>proofed and checked</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="metaStatus" mode="add" usage="opt">
                        <desc versionDate="2010-05-06" xml:lang="en">describes the status of the metadata for a document at the time indicated.</desc>
                        <datatype>
                           <dataRef key="teidata.word"/>
                        </datatype>
                        <valList type="closed" mode="add">
                           <valItem ident="empty" mode="add">
                              <desc>metadata empty</desc>
                              <gloss>empty / not yet worked on or edited</gloss>
                           </valItem>
                           <valItem ident="inProgress" mode="add">
                              <desc>metadata in progress</desc>
                              <gloss>currently being worked on, but not yet "done"</gloss>
                           </valItem>
                           <valItem ident="done" mode="add">
                              <desc>metadata done</desc>
                              <gloss>Metadata work is completed</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.editLike" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="instant" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.edition" module="tei" type="atts" mode="delete"/><classSpec ident="att.fragmentable" module="tei" type="atts" mode="delete"/><classSpec ident="att.global" module="tei" type="atts" mode="change">
                  <classes mode="change">
              <!--Remove facs and responsibility from the global modules,
                so we can add them on the individual elements that we need-->
                     <memberOf key="att.global.facs" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="delete"/>
                     <memberOf key="att.global.linking" mode="delete"/>
                     <memberOf key="att.global.analytic" mode="delete"/>
                     <memberOf key="lim.att.global.fragmentable" mode="add"/>
                  </classes>
                  <constraintSpec ident="allIdsMustBeUnique" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           
                           <sch:rule context="*[@xml:id]">
                              <sch:let name="allIds" value="//*[@xml:id]/@xml:id"/>
                              <sch:let name="myId" value="@xml:id"/>
                              
                              <sch:assert test="count($allIds[. = $myId]) = 1">ERROR: Duplicate id found <sch:value-of select="$myId"/></sch:assert>
                           </sch:rule>
                         
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
              <!--We'll never need space or base, afaik-->
                     <attDef ident="xml:space" mode="delete"/>
                     <attDef ident="xml:base" mode="delete"/>
                  </attList>
                  
               </classSpec><classSpec ident="att.global.analytic" type="atts" mode="change">
                  <constraintSpec ident="att.global.analytic.distinctValues" scheme="schematron">
                     <desc><att>ana</att> values should all be distinct</desc>
                     <constraint>
                        <sch:rule context="*[@ana]">
                           <sch:let name="values" value="tokenize(@ana,'\s+')"/>
                           <sch:let name="dups" value="for $v in $values return if (count(index-of($values, $v)) gt 1) then $v else ()"/>
                           <sch:assert test="empty($dups)">
                              ERROR: Do not repeat @ana values (duplicate values found: <sch:value-of select="string-join(distinct-values($dups),', ')"/>)
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="ana" mode="change">
                        <datatype minOccurs="1" maxOccurs="unbounded">
                           <dataRef key="limdata.ana"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.global.facs" type="atts" mode="change">
                  <!--Restrict the use of @facs to only allow lib:-->
                  <attList>
                     <attDef ident="facs" mode="change">
                        <datatype maxOccurs="1">
                           <dataRef key="limdata.facs"/>
                        </datatype>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>The facs attribute should contain only a single pointer of the limdata.facs.</p>
                  </remarks>
               </classSpec><classSpec ident="att.global.linking" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="synch" mode="delete"/>
                     <attDef ident="sameAs" mode="delete"/>
                     <attDef ident="next" mode="delete"/>
                     <attDef ident="prev" mode="delete"/>
                     <attDef ident="exclude" mode="delete"/>
                     <attDef ident="select" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.global.rendition" module="tei" type="atts" mode="change">
                  <constraintSpec scheme="schematron" ident="rendition.onlyInBornDigital" mode="add">
                     <desc>Constraints for renditions that should only be used in
                     born digital documents</desc>
                     <constraint>
                        <sch:rule context="tei:*[contains-token(@rendition,'rnd:hidden')]">
                           <sch:assert test="self::tei:head and ancestor::tei:TEI/descendant::tei:catRef[matches(@target,'bornDigital')]">ERROR: rnd:hidden is meant only for born digital document headings.</sch:assert>
                        </sch:rule>
                        
                     </constraint>
                  </constraintSpec>
                  <attList>
              <!--Delete @rend, since it's too ambiguous to be useful-->
                     <attDef ident="rend" mode="delete"/>
                     <!--Delete style unless we think that's important-->
                     <attDef ident="style" mode="delete"/>
                     <!--And constraint rendition-->
                     <attDef ident="rendition" mode="change">
                        <constraintSpec ident="rendition.twoColumnNeedsLeftAndRight" scheme="schematron" mode="add">
                           <desc>The two column layout requires one item to be left and one item to be right.</desc>
                           <constraint>
                              <sch:rule context="tei:*[contains-token(@rendition,'rnd:two-column')]">
                                 <sch:let name="children" value="child::tei:*"/>
                                 <sch:let name="leftChild" value="$children[contains-token(@rendition,'rnd:left')]"/>
                                 <sch:let name="rightChild" value="$children[contains-token(@rendition, 'rnd:right')]"/>
                                 <sch:assert test="exists($children) and (count(($leftChild, $rightChild)) = count($children))">ERROR: Every child of a two column layout must have either a rnd:right or a rnd:left rendition value.</sch:assert>
                                 <sch:assert test="exists($leftChild) and exists($rightChild)">ERROR: There must be at least one rnd:left and one rnd:right child</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                        <constraintSpec ident="rendition.mutualExclusion" scheme="schematron" mode="add">
                           <desc>Some renditions contradict each other</desc>
                           <constraint>
                              <sch:rule context="tei:*[@rendition]">
                                 <sch:let name="rendition" value="@rendition"/>
                                 <sch:let name="ptrs" value="tokenize(@rendition,'\s+')"/>
                                 <sch:let name="tokens" value="for $p in $ptrs return substring-after($p,'rnd:')"/>
                                 <sch:let name="duplicates" value="$tokens[count(index-of($tokens, .)) gt 1]"/>
                                 <sch:assert test="empty($duplicates)">ERROR: Duplicate renditions found: <sch:value-of select="string-join($duplicates,', ')"/>. Do not use the same rendition more than once on a single element.</sch:assert>
                                 <sch:assert test="count($tokens[. = ('left','right','center')]) lt 2">ERROR: rnd:right, rnd:left, or rnd:center are mutually exclusive.</sch:assert>
                                 <sch:assert test="count($tokens[. = ('large','small')]) lt 2">ERROR: rnd:large and rnd:small are mutually exclusive.</sch:assert>
                                 <sch:assert test="count($tokens[. = ('bordered-bottom','bordered-bottom-dashed')]) lt 2">ERROR: rnd:bordered-bottom and rnd:bordered-bottom-dashed are mutually exclusive.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                        <valList type="closed" mode="add">
                           <!--Auto-filled by XSLT: ${pd}/code/schema/fill_odd.xsl -->
                        </valList>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.naming" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="nymRef" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.notated" module="tei" type="atts" mode="delete"/><classSpec ident="att.personal" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="full" mode="delete"/>
                     <attDef ident="sort" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.placement" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="place" mode="change">
                        <datatype>
                           <dataRef key="limdata.placement"/>
                        </datatype>
                        <valList mode="delete"/>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.pointing" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="targetLang" mode="delete"/>
                     <attDef ident="evaluate" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.pointing.group" mode="delete" module="tei" type="atts"/><classSpec ident="att.segLike" module="tei" mode="change" type="atts">
                  <attList>
                     <attDef ident="function" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.sortable" module="tei" type="atts" mode="delete"/><classSpec ident="att.timed" module="tei" type="atts" mode="delete"/><classSpec ident="att.transcriptional" module="tei" type="atts" mode="delete"/><classSpec ident="att.typed" module="tei" type="atts" mode="change">
                  <attList>
              <!--Remove subtype for now-->
                     <attDef ident="subtype" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.written" module="tei" type="atts" mode="change">
                  <constraintSpec ident="hand.mustUseLocalPointer" mode="add" scheme="schematron">
                     <desc>All <att>hand</att> attributes should point 
                        to a locally defined hand.</desc>
                     <constraint>
                        <sch:rule context="tei:*[@hand]">
                           <sch:let name="hand" value="@hand"/>
                           <sch:let name="ptrs" value="tokenize($hand,'\s+')"/>
                           <sch:let name="handNotes" value="ancestor::tei:TEI//tei:handNote"/>
                           <sch:let name="unmatched" value="for $p in $ptrs                               return                                   if                                   ($handNotes[@xml:id = substring-after($p,'#')])                                     then ()                                   else $p"/>
                           <sch:assert test="every $p in $ptrs satisfies starts-with($p,'#')">ERROR: All @hand values must start with a # to point to a locally defined handNote.</sch:assert>
                           <sch:assert test="empty($unmatched)">ERROR: Cannot find associated handNotes for <sch:value-of select="string-join($unmatched, ' ')"/></sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </classSpec><dataSpec module="tei" ident="teidata.language" mode="change">
                  <content>
                     <alternate>
                        <dataRef name="language"/>
                        <!--Add the subset of languages we know we might use
                  so far-->
                        <valList mode="add" type="semi">
                           <valItem ident="la">
                              <desc>la</desc>
                              <gloss>Latin</gloss>
                           </valItem>
                           <valItem ident="en">
                              <desc>en</desc>
                              <gloss>English</gloss>
                           </valItem>
                           <valItem ident="fr">
                              <desc>fr</desc>
                              <gloss>French</gloss>
                           </valItem>
                           <valItem ident="gr">
                              <desc>gr</desc>
                              <gloss>Greek</gloss>
                           </valItem>
                           <valItem ident="ga">
                              <desc>ga</desc>
                              <gloss>Irish</gloss>
                           </valItem>
                           <valItem ident="gd">
                              <desc>gd</desc>
                              <gloss>Scottish Gaelic</gloss>
                           </valItem>
                           <valItem ident="de">
                              <desc>de</desc>
                              <gloss>German</gloss>
                           </valItem>
                           <valItem ident="es">
                              <desc>es</desc>
                              <gloss>Spanish</gloss>
                           </valItem>
                           <valItem ident="sco">
                              <desc>sco</desc>
                              <gloss>Scots</gloss>
                           </valItem>
                           <valItem ident="ghc">
                              <desc>ghc</desc>
                              <gloss>Hiberno-Scottish Gaelic</gloss>
                           </valItem>
                           <valItem ident="it">
                              <desc>it</desc>
                              <gloss>Italian</gloss>
                           </valItem>
                        </valList>
                     </alternate>
                  </content>
               </dataSpec>
               <moduleRef key="textstructure" include="TEI body byline closer dateline div docAuthor docDate docEdition docImprint docTitle epigraph front imprimatur opener postscript salute signed text titlePage titlePart trailer"/><elementSpec ident="closer" module="textstructure" mode="change">
                  <content>
                     <macroRef key="lim.macro.openerAndCloserContent"/>
                  </content>
               </elementSpec><elementSpec ident="div" mode="change" module="textstructure">
                  <constraintSpec ident="div.onlyRootWithIndexAndVolume11" scheme="schematron" mode="add">
                     <desc>Only index divs are allowed as a root div element and only for vol 11.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="/tei:div">
                              <sch:assert test="@type = 'index'">ERROR: Only divisions with @type='index' are allowed
                      as root elements.</sch:assert>
                              <sch:assert test="matches($uri,'vol11_')">ERROR: Only use root divs for volume 11.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList mode="add" type="closed">
                           <valItem ident="index">
                              <gloss>index</gloss>
                              <desc>An index/table of contents for a single volume.</desc>
                           </valItem>
                           <valItem ident="preface">
                              <gloss>preface</gloss>
                              <desc>A preface or some prefatory matter to a volume or text.</desc>
                           </valItem>
                           <valItem ident="footnotes">
                              <gloss>footnotes</gloss>
                              <desc>A set of footnotes</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="opener" module="textstructure" mode="change">
                  <content>
                     <macroRef key="lim.macro.openerAndCloserContent"/>
                  </content>
               </elementSpec><macroSpec module="textstructure" ident="lim.macro.openerAndCloserContent">
                  <gloss>Openers and closers content</gloss>
                  <desc>A macro specification for openers and closers, since their content
                  models are fairly limited, but should be kept aligned.</desc>
                  <content>
                     <alternate minOccurs="1" maxOccurs="unbounded">
                        <elementRef key="signed"/>
                        <elementRef key="dateline"/>
                        <elementRef key="salute"/>
                        <classRef key="model.milestoneLike"/>
                     </alternate>
                  </content>
               </macroSpec>
               <moduleRef key="transcr" include="damage facsimile fw handNotes handShift metamark space subst supplied surface surfaceGrp zone"/><elementSpec ident="facsimile" module="transcr" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="fw" module="transcr" mode="change">
                  <constraintSpec ident="fw.pageNum.mustHavePlace" scheme="schematron">
                     <desc>All pageNum formeworks must have an @place</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:fw[@type=('pageNum', 'folioNum')]">
                              <sch:assert test="@place">ERROR: Missing required @place attribute for page number formework.</sch:assert>
                           </sch:rule>
                           <!--<sch:rule context="tei:fw[@type='catchword']">
                              <sch:let name="firstFollowingEl" value="following::tei:*[1]"/>
                              <sch:assert test="empty($firstFollowingEl) or $firstFollowingEl/self::tei:pb">ERROR: All catchwords should have a page beginning after</sch:assert>
                           </sch:rule>-->
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem ident="pageNum">
                              <gloss>page number</gloss>
                              <desc>A page number, usually written on the top left or right hand sides of a page.</desc>
                           </valItem>
                           <valItem ident="catchword">
                              <gloss>catchword</gloss>
                              <desc>A catchword, usually on the bottom right of the page.</desc>
                           </valItem>
                           <valItem ident="sig">
                              <gloss>signature</gloss>
                              <desc>A page signature, usually on the bottom center of the page.</desc>
                           </valItem>
                           <valItem ident="folioNum">
                              <gloss>folio number</gloss>
                              <desc>A folio number, usually written on the top left or right hand sides of a page.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="metamark" module="transcr" mode="change">
                  <!--Delete all class membership, since we don't want this appearing
                     anywhere but within ellipsis-->
                  <classes mode="replace"/>
                  <content>
                     <alternate minOccurs="1" maxOccurs="1">
                        <elementRef key="space"/>
                        <textNode/>
                     </alternate>
                  </content>
                  <constraintSpec ident="metamark.actualContentOrSpace" scheme="schematron">
                     <desc>All metamarks should contain actual content or the <gi>space</gi> element</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:metamark[not(tei:space)]">
                              <sch:assert test="matches(string(.),'\S')">ERROR: Metamarks must contain
                                 either text content or the &lt;space&gt; element.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <remarks>
                     <p><gi>metamark</gi>s should only appear within the <gi>ellipsis</gi> element and should contain either 
                     meaningful text-content or the <gi>space</gi> element.</p>
                  </remarks>
               </elementSpec><elementSpec ident="space" module="transcr" mode="change">
                  <classes mode="replace"/>
                  <remarks>
                     <p>The <gi>space</gi> element should be used only within the <gi>metamark</gi> element (which itself is 
                     only used within the <gi>ellipsis</gi> element).</p>
                  </remarks>
                  
               </elementSpec><elementSpec ident="supplied" module="transcr" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.ranging" mode="delete"/>
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.editLike" mode="delete"/>
                  </classes>
               </elementSpec><classSpec ident="att.global.change" module="transcr" type="atts" mode="delete"/>
            </schemaSpec>
         </div>
      </back>
   </text>
</TEI>